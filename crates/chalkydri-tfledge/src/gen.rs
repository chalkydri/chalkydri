/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __GNUC_VA_LIST: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const kTfLiteOptionalTensor: i32 = -1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(u32)]
#[doc = " Note that new error status values may be added in future in order to\n indicate more fine-grained internal states, therefore, applications should\n not rely on status values being members of the enum."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteStatus {
    #[doc = " Success"]
    kTfLiteOk = 0,
    #[doc = " Generally referring to an error in the runtime (i.e. interpreter)"]
    kTfLiteError = 1,
    #[doc = " Generally referring to an error from a TfLiteDelegate itself."]
    kTfLiteDelegateError = 2,
    #[doc = " Generally referring to an error in applying a delegate due to\n incompatibility between runtime and delegate, e.g., this error is returned\n when trying to apply a TF Lite delegate onto a model graph that's already\n immutable."]
    kTfLiteApplicationError = 3,
    #[doc = " Generally referring to serialized delegate data not being found.\n See tflite::delegates::Serialization."]
    kTfLiteDelegateDataNotFound = 4,
    #[doc = " Generally referring to data-writing issues in delegate serialization.\n See tflite::delegates::Serialization."]
    kTfLiteDelegateDataWriteError = 5,
    #[doc = " Generally referring to data-reading issues in delegate serialization.\n See tflite::delegates::Serialization."]
    kTfLiteDelegateDataReadError = 6,
    #[doc = " Generally referring to issues when the TF Lite model has ops that cannot\n be resolved at runtime. This could happen when the specific op is not\n registered or built with the TF Lite framework."]
    kTfLiteUnresolvedOps = 7,
    #[doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."]
    kTfLiteCancelled = 8,
}
#[repr(u32)]
#[doc = " Types supported by tensor"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteType {
    kTfLiteNoType = 0,
    kTfLiteFloat32 = 1,
    kTfLiteInt32 = 2,
    kTfLiteUInt8 = 3,
    kTfLiteInt64 = 4,
    kTfLiteString = 5,
    kTfLiteBool = 6,
    kTfLiteInt16 = 7,
    kTfLiteComplex64 = 8,
    kTfLiteInt8 = 9,
    kTfLiteFloat16 = 10,
    kTfLiteFloat64 = 11,
    kTfLiteComplex128 = 12,
    kTfLiteUInt64 = 13,
    kTfLiteResource = 14,
    kTfLiteVariant = 15,
    kTfLiteUInt32 = 16,
    kTfLiteUInt16 = 17,
    kTfLiteInt4 = 18,
    kTfLiteBFloat16 = 19,
}
#[doc = " Legacy. Will be deprecated in favor of `TfLiteAffineQuantization`.\n If per-layer quantization is specified this field will still be populated in\n addition to `TfLiteAffineQuantization`.\n Parameters for asymmetric quantization. Quantized values can be converted\n back to float using: `real_value = scale * (quantized_value - zero_point)`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantizationParams {
    pub scale: f32,
    pub zero_point: i32,
}
#[test]
fn bindgen_test_layout_TfLiteQuantizationParams() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteQuantizationParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteQuantizationParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteQuantizationParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zero_point) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(zero_point)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueTensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueDelegateStruct {
    _unused: [u8; 0],
}
#[doc = " WARNING: This is an experimental interface that is subject to change."]
pub type TfLiteOpaqueDelegate = TfLiteDelegate;
#[repr(u32)]
#[doc = " The list of external context types known to TF Lite. This list exists solely\n to avoid conflicts and to ensure ops can share the external contexts they\n need. Access to the external contexts is controlled by one of the\n corresponding support files."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteExternalContextType {
    kTfLiteEigenContext = 0,
    #[doc = " include eigen_support.h to use."]
    kTfLiteGemmLowpContext = 1,
    #[doc = " include gemm_support.h to use."]
    kTfLiteEdgeTpuContext = 2,
    #[doc = " Placeholder for Edge TPU support."]
    kTfLiteCpuBackendContext = 3,
    #[doc = " include cpu_backend_context.h to use."]
    kTfLiteMaxExternalContexts = 4,
}
#[doc = " An external context is a collection of information unrelated to the TF Lite\n framework, but useful to a subset of the ops. TF Lite knows very little\n about the actual contexts, but it keeps a list of them, and is able to\n refresh them if configurations like the number of recommended threads\n change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteExternalContext {
    pub type_: TfLiteExternalContextType,
    pub Refresh:
        ::core::option::Option<unsafe extern "C" fn(context: *mut TfLiteContext) -> TfLiteStatus>,
}
#[test]
fn bindgen_test_layout_TfLiteExternalContext() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteExternalContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteExternalContext>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteExternalContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Refresh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(Refresh)
        )
    );
}
#[doc = " Fixed size list of integers. Used for dimensions and inputs/outputs tensor\n indices"]
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteIntArray {
    pub size: ::core::ffi::c_int,
    pub data: __IncompleteArrayField<::core::ffi::c_int>,
}
#[test]
fn bindgen_test_layout_TfLiteIntArray() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteIntArray> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteIntArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteIntArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Given the size (number of elements) in a TfLiteIntArray, calculate its size\n in bytes."]
    pub fn TfLiteIntArrayGetSizeInBytes(size: ::core::ffi::c_int) -> usize;
}
extern "C" {
    #[doc = " Create a array of a given `size` (uninitialized entries).\n This returns a pointer, that you must free using TfLiteIntArrayFree()."]
    pub fn TfLiteIntArrayCreate(size: ::core::ffi::c_int) -> *mut TfLiteIntArray;
}
extern "C" {
    #[doc = " Check if two intarrays are equal. Returns 1 if they are equal, 0 otherwise."]
    pub fn TfLiteIntArrayEqual(
        a: *const TfLiteIntArray,
        b: *const TfLiteIntArray,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Check if an intarray equals an array. Returns 1 if equals, 0 otherwise."]
    pub fn TfLiteIntArrayEqualsArray(
        a: *const TfLiteIntArray,
        b_size: ::core::ffi::c_int,
        b_data: *const ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Create a copy of an array passed as `src`.\n You are expected to free memory with TfLiteIntArrayFree"]
    pub fn TfLiteIntArrayCopy(src: *const TfLiteIntArray) -> *mut TfLiteIntArray;
}
extern "C" {
    #[doc = " Free memory of array `a`."]
    pub fn TfLiteIntArrayFree(a: *mut TfLiteIntArray);
}
#[doc = " Fixed size list of floats. Used for per-channel quantization."]
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteFloatArray {
    pub size: ::core::ffi::c_int,
    pub data: __IncompleteArrayField<f32>,
}
#[test]
fn bindgen_test_layout_TfLiteFloatArray() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteFloatArray> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Given the size (number of elements) in a TfLiteFloatArray, calculate its\n size in bytes."]
    pub fn TfLiteFloatArrayGetSizeInBytes(size: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Create a array of a given `size` (uninitialized entries).\n This returns a pointer, that you must free using TfLiteFloatArrayFree()."]
    pub fn TfLiteFloatArrayCreate(size: ::core::ffi::c_int) -> *mut TfLiteFloatArray;
}
extern "C" {
    #[doc = " Create a copy of an array passed as `src`.\n You are expected to free memory with TfLiteFloatArrayFree."]
    pub fn TfLiteFloatArrayCopy(src: *const TfLiteFloatArray) -> *mut TfLiteFloatArray;
}
extern "C" {
    #[doc = " Free memory of array `a`."]
    pub fn TfLiteFloatArrayFree(a: *mut TfLiteFloatArray);
}
#[doc = " Single-precision complex data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex64 {
    pub re: f32,
    pub im: f32,
}
#[test]
fn bindgen_test_layout_TfLiteComplex64() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteComplex64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteComplex64>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteComplex64>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(im)
        )
    );
}
#[doc = " Double-precision complex data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex128 {
    pub re: f64,
    pub im: f64,
}
#[test]
fn bindgen_test_layout_TfLiteComplex128() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteComplex128> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteComplex128>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteComplex128>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(im)
        )
    );
}
#[doc = " Half precision data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteFloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_TfLiteFloat16() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteFloat16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteFloat16>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteFloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloat16),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " bfloat16 data type compatible with the Google Brain definition.\n https://cloud.google.com/tpu/docs/bfloat16.\n This provides 1 bit of sign, 8 bits of exponent, and 7 bits of mantissa."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBFloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_TfLiteBFloat16() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteBFloat16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteBFloat16>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteBFloat16))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteBFloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(TfLiteBFloat16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBFloat16),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Return the name of a given type, for error reporting purposes."]
    pub fn TfLiteTypeGetName(type_: TfLiteType) -> *const ::core::ffi::c_char;
}
#[repr(u32)]
#[doc = " SupportedQuantizationTypes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteQuantizationType {
    #[doc = " No quantization."]
    kTfLiteNoQuantization = 0,
    #[doc = " Affine quantization (with support for per-channel quantization).\n Corresponds to TfLiteAffineQuantization."]
    kTfLiteAffineQuantization = 1,
}
#[doc = " Structure specifying the quantization used by the tensor, if-any."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantization {
    #[doc = " The type of quantization held by params."]
    pub type_: TfLiteQuantizationType,
    #[doc = " Holds an optional reference to a quantization param structure. The actual\n type depends on the value of the `type` field (see the comment there for\n the values and corresponding types)."]
    pub params: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_TfLiteQuantization() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteQuantization> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteQuantization>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteQuantization>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(params)
        )
    );
}
#[doc = " Parameters for asymmetric quantization across a dimension (i.e per output\n channel quantization).\n quantized_dimension specifies which dimension the scales and zero_points\n correspond to.\n For a particular value in quantized_dimension, quantized values can be\n converted back to float using:\n     `real_value = scale * (quantized_value - zero_point)`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAffineQuantization {
    pub scale: *mut TfLiteFloatArray,
    pub zero_point: *mut TfLiteIntArray,
    pub quantized_dimension: i32,
}
#[test]
fn bindgen_test_layout_TfLiteAffineQuantization() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteAffineQuantization> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteAffineQuantization>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteAffineQuantization))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteAffineQuantization>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteAffineQuantization))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zero_point) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(zero_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quantized_dimension) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(quantized_dimension)
        )
    );
}
#[doc = " A union of pointers that points to memory for a given tensor.\n\n Do not access these members directly, if possible, use\n `GetTensorData<TYPE>(tensor)` instead, otherwise only access `.data`, as\n other members are deprecated."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union TfLitePtrUnion {
    pub i32_: *mut i32,
    pub u32_: *mut u32,
    pub i64_: *mut i64,
    pub u64_: *mut u64,
    pub f: *mut f32,
    pub f16: *mut TfLiteFloat16,
    pub f64_: *mut f64,
    pub raw: *mut ::core::ffi::c_char,
    pub raw_const: *const ::core::ffi::c_char,
    pub uint8: *mut u8,
    pub b: *mut bool,
    pub i16_: *mut i16,
    pub ui16: *mut u16,
    pub c64: *mut TfLiteComplex64,
    pub c128: *mut TfLiteComplex128,
    pub int8: *mut i8,
    #[doc = " Only use this member."]
    pub data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_TfLitePtrUnion() {
    const UNINIT: ::core::mem::MaybeUninit<TfLitePtrUnion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Size of: ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw_const) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw_const)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(uint8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ui16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(ui16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(int8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(data)
        )
    );
}
#[repr(u32)]
#[doc = " Memory allocation strategies.\n  * `kTfLiteMmapRo`: Read-only memory-mapped data, or data externally\n        allocated.\n  * `kTfLiteArenaRw`: Arena allocated with no guarantees about persistence,\n        and available during eval.\n  * `kTfLiteArenaRwPersistent`: Arena allocated but persistent across eval,\n  and only available during eval.\n  * `kTfLiteDynamic`: Allocated during eval, or for string tensors.\n  * `kTfLitePersistentRo`: Allocated and populated during prepare. This is\n        useful for tensors that can be computed during prepare and treated\n        as constant inputs for downstream ops (also in prepare).\n  * `kTfLiteCustom`: Custom memory allocation provided by the user. See\n        TfLiteCustomAllocation below.\n  * `kTfLiteVariantObject`: Allocation is an arbitrary type-erased C++\n  object.\n        Allocation and deallocation are done through `new` and `delete`."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteAllocationType {
    kTfLiteMemNone = 0,
    kTfLiteMmapRo = 1,
    kTfLiteArenaRw = 2,
    kTfLiteArenaRwPersistent = 3,
    kTfLiteDynamic = 4,
    kTfLitePersistentRo = 5,
    kTfLiteCustom = 6,
    kTfLiteVariantObject = 7,
}
#[repr(u32)]
#[doc = " Memory allocation strategies.\n\n TfLiteAllocationType values have been overloaded to mean more than their\n original intent. This enum should only be used to document the allocation\n strategy used by a tensor for it data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteAllocationStrategy {
    kTfLiteAllocationStrategyUnknown = 0,
    kTfLiteAllocationStrategyNone = 1,
    #[doc = " No data is allocated."]
    kTfLiteAllocationStrategyMMap = 2,
    #[doc = " Data is mmaped."]
    kTfLiteAllocationStrategyArena = 3,
    #[doc = " Handled by the arena."]
    kTfLiteAllocationStrategyMalloc = 4,
    #[doc = " Uses `malloc`/`free`."]
    kTfLiteAllocationStrategyNew = 5,
}
#[repr(u32)]
#[doc = " Describes how stable a tensor attribute is with regards to an interpreter\n runs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteRunStability {
    kTfLiteRunStabilityUnknown = 0,
    kTfLiteRunStabilityUnstable = 1,
    #[doc = " May change at any time."]
    kTfLiteRunStabilitySingleRun = 2,
    #[doc = " Will stay the same for one run."]
    kTfLiteRunStabilityAcrossRuns = 3,
}
#[repr(u32)]
#[doc = " Describes the steps of a TFLite operation life cycle."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteRunStep {
    kTfLiteRunStepUnknown = 0,
    kTfLiteRunStepInit = 1,
    kTfLiteRunStepPrepare = 2,
    kTfLiteRunStepEval = 3,
}
#[doc = " The delegates should use zero or positive integers to represent handles.\n -1 is reserved from unallocated status."]
pub type TfLiteBufferHandle = ::core::ffi::c_int;
pub const kTfLiteNullBufferHandle: _bindgen_ty_1 = _bindgen_ty_1::kTfLiteNullBufferHandle;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    kTfLiteNullBufferHandle = -1,
}
#[repr(u32)]
#[doc = " Storage format of each dimension in a sparse tensor."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteDimensionType {
    kTfLiteDimDense = 0,
    kTfLiteDimSparseCSR = 1,
}
#[doc = " Metadata to encode each dimension in a sparse tensor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDimensionMetadata {
    pub format: TfLiteDimensionType,
    pub dense_size: ::core::ffi::c_int,
    pub array_segments: *mut TfLiteIntArray,
    pub array_indices: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDimensionMetadata() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteDimensionMetadata> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteDimensionMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteDimensionMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dense_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(dense_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_segments) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_segments)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_indices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_indices)
        )
    );
}
#[doc = " Parameters used to encode a sparse tensor. For detailed explanation of each\n field please refer to lite/schema/schema.fbs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSparsity {
    pub traversal_order: *mut TfLiteIntArray,
    pub block_map: *mut TfLiteIntArray,
    pub dim_metadata: *mut TfLiteDimensionMetadata,
    pub dim_metadata_size: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSparsity() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteSparsity> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteSparsity>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteSparsity>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).traversal_order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(traversal_order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(block_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dim_metadata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dim_metadata_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata_size)
        )
    );
}
#[doc = " Defines a custom memory allocation not owned by the runtime.\n `data` should be aligned to kDefaultTensorAlignment defined in\n lite/util.h. (Currently 64 bytes)\n NOTE: See `Interpreter::SetCustomAllocationForTensor` for details on usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteCustomAllocation {
    pub data: *mut ::core::ffi::c_void,
    pub bytes: usize,
}
#[test]
fn bindgen_test_layout_TfLiteCustomAllocation() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteCustomAllocation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteCustomAllocation>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteCustomAllocation))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteCustomAllocation>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteCustomAllocation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCustomAllocation),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCustomAllocation),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(u32)]
#[doc = " The flags used in `Interpreter::SetCustomAllocationForTensor`.\n Note that this is a bitmask, so the values should be 1, 2, 4, 8, ...etc."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteCustomAllocationFlags {
    kTfLiteCustomAllocationFlagsNone = 0,
    #[doc = " Skips checking whether allocation.data points to an aligned buffer as\n expected by the TFLite runtime.\n NOTE: Setting this flag can cause crashes when calling Invoke().\n Use with caution."]
    kTfLiteCustomAllocationFlagsSkipAlignCheck = 1,
}
pub const kTfLiteNoBufferIdentifier: _bindgen_ty_2 = _bindgen_ty_2::kTfLiteNoBufferIdentifier;
#[repr(u64)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    kTfLiteNoBufferIdentifier = 18446744073709551615,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteTensor {
    #[doc = " The data type specification for data stored in `data`. This affects\n what member of `data` union should be used."]
    pub type_: TfLiteType,
    #[doc = " A union of data pointers. The appropriate type should be used for a typed\n tensor based on `type`."]
    pub data: TfLitePtrUnion,
    #[doc = " A pointer to a structure representing the dimensionality interpretation\n that the buffer should have. NOTE: the product of elements of `dims`\n and the element datatype size should be equal to `bytes` below."]
    pub dims: *mut TfLiteIntArray,
    #[doc = " Quantization information."]
    pub params: TfLiteQuantizationParams,
    #[doc = " How memory is mapped\n  kTfLiteMmapRo: Memory mapped read only.\n  i.e. weights\n  kTfLiteArenaRw: Arena allocated read write memory\n  (i.e. temporaries, outputs)."]
    pub allocation_type: TfLiteAllocationType,
    #[doc = " The number of bytes required to store the data of this Tensor. I.e.\n (bytes of each element) * dims[0] * ... * dims[n-1].  For example, if\n type is kTfLiteFloat32 and dims = {3, 2} then\n bytes = sizeof(float) * 3 * 2 = 4 * 3 * 2 = 24."]
    pub bytes: usize,
    #[doc = " An opaque pointer to a tflite::MMapAllocation"]
    pub allocation: *const ::core::ffi::c_void,
    #[doc = " Null-terminated name of this tensor."]
    pub name: *const ::core::ffi::c_char,
    #[doc = " The delegate which knows how to handle `buffer_handle`.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub delegate: *mut TfLiteDelegate,
    #[doc = " An integer buffer handle that can be handled by `delegate`.\n The value is valid only when delegate is not null.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub buffer_handle: TfLiteBufferHandle,
    #[doc = " If the delegate uses its own buffer (e.g. GPU memory), the delegate is\n responsible to set data_is_stale to true.\n `delegate->CopyFromBufferHandle` can be called to copy the data from\n delegate buffer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub data_is_stale: bool,
    #[doc = " True if the tensor is a variable."]
    pub is_variable: bool,
    #[doc = " Quantization information. Replaces params field above."]
    pub quantization: TfLiteQuantization,
    #[doc = " Parameters used to encode a sparse tensor.\n This is optional. The field is NULL if a tensor is dense.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub sparsity: *mut TfLiteSparsity,
    #[doc = " Optional. Encodes shapes with unknown dimensions with -1. This field is\n only populated when unknown dimensions exist in a read-write tensor (i.e.\n an input or output tensor). (e.g.  `dims` contains [1, 1, 1, 3] and\n `dims_signature` contains [1, -1, -1, 3]).  If no unknown dimensions exist\n then `dims_signature` is either null, or set to an empty array.  Note that\n this field only exists when TF_LITE_STATIC_MEMORY is not defined."]
    pub dims_signature: *const TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteTensor() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteTensor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteTensor>(),
        112usize,
        concat!("Size of: ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocation_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_handle) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(buffer_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_is_stale) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data_is_stale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_variable) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(is_variable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quantization) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sparsity) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(sparsity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dims_signature) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims_signature)
        )
    );
}
#[doc = " A structure representing an instance of a node.\n This structure only exhibits the inputs, outputs, user defined data and some\n node properties (like statefulness), not other features like the type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteNode {
    #[doc = " Inputs to this node expressed as indices into the simulator's tensors."]
    pub inputs: *mut TfLiteIntArray,
    #[doc = " Outputs to this node expressed as indices into the simulator's tensors."]
    pub outputs: *mut TfLiteIntArray,
    #[doc = " intermediate tensors to this node expressed as indices into the\n simulator's tensors."]
    pub intermediates: *mut TfLiteIntArray,
    #[doc = " Temporary tensors uses during the computations. This usually contains no\n tensors, but ops are allowed to change that if they need scratch space of\n any sort."]
    pub temporaries: *mut TfLiteIntArray,
    #[doc = " Opaque data provided by the node implementer through `Registration.init`."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Opaque data provided to the node if the node is a builtin. This is usually\n a structure defined in builtin_op_data.h"]
    pub builtin_data: *mut ::core::ffi::c_void,
    #[doc = " Custom initial data. This is the opaque data provided in the flatbuffer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub custom_initial_data: *const ::core::ffi::c_void,
    pub custom_initial_data_size: ::core::ffi::c_int,
    #[doc = " The pointer to the delegate. This is non-null only when the node is\n created by calling `interpreter.ModifyGraphWithDelegate`.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub delegate: *mut TfLiteDelegate,
    #[doc = " Whether this op might have side effect (e.g. stateful op)."]
    pub might_have_side_effect: bool,
}
#[test]
fn bindgen_test_layout_TfLiteNode() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteNode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteNode>(),
        80usize,
        concat!("Size of: ", stringify!(TfLiteNode))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteNode>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteNode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intermediates) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(intermediates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporaries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(temporaries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).builtin_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(builtin_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_initial_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_initial_data_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).might_have_side_effect) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(might_have_side_effect)
        )
    );
}
#[doc = " Light-weight tensor struct for TF Micro runtime. Provides the minimal amount\n of information required for a kernel to run during TfLiteRegistration::Eval."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteEvalTensor {
    #[doc = " A union of data pointers. The appropriate type should be used for a typed\n tensor based on `type`."]
    pub data: TfLitePtrUnion,
    #[doc = " A pointer to a structure representing the dimensionality interpretation\n that the buffer should have."]
    pub dims: *mut TfLiteIntArray,
    #[doc = " The data type specification for data stored in `data`. This affects\n what member of `data` union should be used."]
    pub type_: TfLiteType,
}
#[test]
fn bindgen_test_layout_TfLiteEvalTensor() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteEvalTensor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteEvalTensor>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteEvalTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Free data memory of tensor `t`."]
    pub fn TfLiteTensorDataFree(t: *mut TfLiteTensor);
}
extern "C" {
    #[doc = " Free quantization data."]
    pub fn TfLiteQuantizationFree(quantization: *mut TfLiteQuantization);
}
extern "C" {
    #[doc = " Free sparsity parameters."]
    pub fn TfLiteSparsityFree(sparsity: *mut TfLiteSparsity);
}
extern "C" {
    #[doc = " Free memory of tensor `t`."]
    pub fn TfLiteTensorFree(t: *mut TfLiteTensor);
}
extern "C" {
    #[doc = " Set all of a tensor's fields (and free any previously allocated data)."]
    pub fn TfLiteTensorReset(
        type_: TfLiteType,
        name: *const ::core::ffi::c_char,
        dims: *mut TfLiteIntArray,
        quantization: TfLiteQuantizationParams,
        buffer: *mut ::core::ffi::c_char,
        size: usize,
        allocation_type: TfLiteAllocationType,
        allocation: *const ::core::ffi::c_void,
        is_variable: bool,
        tensor: *mut TfLiteTensor,
    );
}
extern "C" {
    #[doc = " Copies the contents of `src` in `dst`.\n Function does nothing if either `src` or `dst` is passed as nullptr and\n return `kTfLiteOk`.\n Returns `kTfLiteError` if `src` and `dst` doesn't have matching data size.\n Note function copies contents, so it won't create new data pointer\n or change allocation type.\n All Tensor related properties will be copied from `src` to `dst` like\n quantization, sparsity, ..."]
    pub fn TfLiteTensorCopy(src: *const TfLiteTensor, dst: *mut TfLiteTensor) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Change the size of the memory block owned by `tensor` to `num_bytes`.\n Tensors with allocation types other than `kTfLiteDynamic` will be ignored\n and a `kTfLiteOk` will be returned. `tensor`'s internal data buffer will be\n assigned a pointer which can safely be passed to free or realloc if\n `num_bytes` is zero. If `preserve_data` is true, tensor data will be\n unchanged in the range from the start of the region up to the minimum of the\n old and new sizes. In the case of NULL tensor, or an error allocating new\n memory, returns `kTfLiteError`."]
    pub fn TfLiteTensorResizeMaybeCopy(
        num_bytes: usize,
        tensor: *mut TfLiteTensor,
        preserve_data: bool,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Change the size of the memory block owned by `tensor` to `num_bytes`.\n Tensors with allocation types other than `kTfLiteDynamic` will be ignored\n and a `kTfLiteOk` will be returned. `tensor`'s internal data buffer will be\n assigned a pointer which can safely be passed to free or realloc if\n `num_bytes` is zero. Tensor data will be unchanged in the range from the\n start of the region up to the minimum of the old and new sizes. In the case\n of NULL tensor, or an error allocating new memory, returns `kTfLiteError`."]
    pub fn TfLiteTensorRealloc(num_bytes: usize, tensor: *mut TfLiteTensor) -> TfLiteStatus;
}
#[doc = " WARNING: This is an experimental interface that is subject to change.\n\n Currently, TfLiteDelegateParams has to be allocated in a way that it's\n trivially destructable. It will be stored as `builtin_data` field in\n `TfLiteNode` of the delegate node.\n\n See also the `CreateDelegateParams` function in `interpreter.cc` details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegateParams {
    pub delegate: *mut TfLiteDelegate,
    pub nodes_to_replace: *mut TfLiteIntArray,
    pub input_tensors: *mut TfLiteIntArray,
    pub output_tensors: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDelegateParams() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteDelegateParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteDelegateParams>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteDelegateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nodes_to_replace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(nodes_to_replace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_tensors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(input_tensors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_tensors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(output_tensors)
        )
    );
}
#[doc = " WARNING: This is an experimental interface that is subject to change.\n\n Currently, TfLiteOpaqueDelegateParams has to be allocated in a way that it's\n trivially destructable. It will be stored as `builtin_data` field in\n `TfLiteNode` of the delegate node.\n\n See also the `CreateOpaqueDelegateParams` function in `subgraph.cc`\n details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueDelegateParams {
    pub delegate: *mut TfLiteOpaqueDelegate,
    pub delegate_data: *mut ::core::ffi::c_void,
    pub nodes_to_replace: *mut TfLiteIntArray,
    pub input_tensors: *mut TfLiteIntArray,
    pub output_tensors: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteOpaqueDelegateParams() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteOpaqueDelegateParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteOpaqueDelegateParams>(),
        40usize,
        concat!("Size of: ", stringify!(TfLiteOpaqueDelegateParams))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteOpaqueDelegateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteOpaqueDelegateParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateParams),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delegate_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateParams),
            "::",
            stringify!(delegate_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nodes_to_replace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateParams),
            "::",
            stringify!(nodes_to_replace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_tensors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateParams),
            "::",
            stringify!(input_tensors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_tensors) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateParams),
            "::",
            stringify!(output_tensors)
        )
    );
}
#[doc = " `TfLiteContext` allows an op to access the tensors.\n\n `TfLiteContext` is a struct that is created by the TF Lite runtime\n and passed to the \"methods\" (C function pointers) in the\n `TfLiteRegistration` struct that are used to define custom ops and custom\n delegate kernels. It contains information and methods (C function pointers)\n that can be called by the code implementing a custom op or a custom delegate\n kernel. These methods provide access to the context in which that custom op\n or custom delegate kernel occurs, such as access to the input and output\n tensors for that op, as well as methods for allocating memory buffers\n and intermediate tensors, etc.\n\n See also `TfLiteOpaqueContext`, which is an more ABI-stable equivalent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteContext {
    #[doc = " Number of tensors in the context."]
    pub tensors_size: usize,
    #[doc = " The execution plan contains a list of the node indices in execution\n order. execution_plan->size is the current number of nodes. And,\n execution_plan->data[0] is the first node that needs to be run.\n TfLiteDelegates can traverse the current execution plan by iterating\n through each member of this array and using GetNodeAndRegistration() to\n access details about a node. i.e.\n\n\n     TfLiteIntArray* execution_plan;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context,\n                                                     &execution_plan));\n     for (int exec_index = 0; exec_index < execution_plan->size;\n           exec_index++) {\n        int node_index = execution_plan->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n     }\n\n Note: the memory pointed by '`*execution_plan` is OWNED by TfLite runtime.\n Future calls to GetExecutionPlan invalidates earlier outputs. The\n following code snippet shows the issue of such an invocation pattern.\n After calling CheckNode, subsequent access to `plan_1st` is undefined.\n\n     void CheckNode(const TfLiteNode* node) {\n       ...\n       TfLiteIntArray* plan_2nd;\n       TF_LITE_ENSURE_STATUS(\n           context->GetExecutionPlan(context, &plan_2nd)\n       );\n       ...\n     }\n\n     TfLiteIntArray* plan_1st;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context, &plan_1st));\n     for (int exec_index = 0; exec_index < plan_1st->size; exec_index++) {\n        int node_index = plan_1st->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n        CheckNode(node);\n     }\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetExecutionPlan: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            execution_plan: *mut *mut TfLiteIntArray,
        ) -> TfLiteStatus,
    >,
    #[doc = " An array of tensors in the interpreter context (of length `tensors_size`)"]
    pub tensors: *mut TfLiteTensor,
    #[doc = " opaque full context ptr (an opaque c++ data structure)"]
    pub impl_: *mut ::core::ffi::c_void,
    #[doc = " Request memory pointer be resized. Updates dimensions on the tensor.\n NOTE: ResizeTensor takes ownership of newSize."]
    pub ResizeTensor: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            new_size: *mut TfLiteIntArray,
        ) -> TfLiteStatus,
    >,
    #[doc = " Request that an error be reported with format string msg."]
    pub ReportError: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut TfLiteContext, msg: *const ::core::ffi::c_char, ...),
    >,
    #[doc = " Add `tensors_to_add` tensors, preserving pre-existing Tensor entries.  If\n non-null, the value pointed to by `first_new_tensor_index` will be set to\n the index of the first new tensor."]
    pub AddTensors: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensors_to_add: ::core::ffi::c_int,
            first_new_tensor_index: *mut ::core::ffi::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Get a Tensor node by node_index.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetNodeAndRegistration: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            node_index: ::core::ffi::c_int,
            node: *mut *mut TfLiteNode,
            registration: *mut *mut TfLiteRegistration,
        ) -> TfLiteStatus,
    >,
    #[doc = " Replace ops with one or more stub delegate operations. This function\n does not take ownership of `nodes_to_replace`."]
    pub ReplaceNodeSubsetsWithDelegateKernels: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            registration: TfLiteRegistration,
            nodes_to_replace: *const TfLiteIntArray,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus,
    >,
    #[doc = " Number of threads that are recommended to subsystems like gemmlowp and\n eigen."]
    pub recommended_num_threads: ::core::ffi::c_int,
    #[doc = " Access external contexts by type.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetExternalContext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType,
        ) -> *mut TfLiteExternalContext,
    >,
    #[doc = " Set the value of a external context. Does not take ownership of the\n pointer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub SetExternalContext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType,
            arg3: *mut TfLiteExternalContext,
        ),
    >,
    #[doc = " Flag for allowing float16 precision for FP32 calculation.\n default: false.\n\n WARNING: This is an experimental API and subject to change."]
    pub allow_fp32_relax_to_fp16: bool,
    #[doc = " Pointer to the op-level profiler, if set; nullptr otherwise."]
    pub profiler: *mut ::core::ffi::c_void,
    #[doc = " Allocate persistent buffer which has the same life time as the\n interpreter. Returns `nullptr` on failure. The memory is allocated from\n heap for TFL, and from tail in TFLM. This method is only available in\n `Init` or `Prepare` stage.\n\n WARNING: This is an experimental interface that is subject\n to change."]
    pub AllocatePersistentBuffer: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut TfLiteContext, bytes: usize) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " Allocate a buffer which will be deallocated right after invoke phase.\n The memory is allocated from heap in TFL, and from volatile arena in TFLM.\n This method is only available in invoke stage.\n\n NOTE: If possible use `RequestScratchBufferInArena` method to avoid memory\n allocation during inference time.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub AllocateBufferForEval: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            ptr: *mut *mut ::core::ffi::c_void,
        ) -> TfLiteStatus,
    >,
    #[doc = " Request a scratch buffer in the arena through static memory planning.\n This method is only available in `Prepare` stage and the buffer is\n allocated by the interpreter between Prepare and Eval stage. In `Eval`\n stage, `GetScratchBuffer` API can be used to fetch the address.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub RequestScratchBufferInArena: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            buffer_idx: *mut ::core::ffi::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Get the scratch buffer pointer.\n This method is only available in Eval stage.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetScratchBuffer: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            buffer_idx: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " Resize the memory pointer of the `tensor`. This method behaves the same as\n `ResizeTensor`, except that it makes a copy of the shape array internally\n so the shape array could be deallocated right afterwards.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub ResizeTensorExplicit: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            dims: ::core::ffi::c_int,
            shape: *const ::core::ffi::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " This method provides a preview of post-delegation partitioning. Each\n TfLiteDelegateParams in the referenced array corresponds to one instance\n of the delegate kernel. Example usage:\n\n     TfLiteIntArray* nodes_to_replace = ...;\n     TfLiteDelegateParams* params_array;\n     int num_partitions = 0;\n     TF_LITE_ENSURE_STATUS(context->PreviewDelegatePartitioning(\n        context, delegate, nodes_to_replace, &params_array,\n        &num_partitions));\n     for (int idx = 0; idx < num_partitions; idx++) {\n        const auto& partition_params = params_array[idx];\n        ...\n     }\n\n NOTE: The context owns the memory referenced by partition_params_array. It\n will be cleared with another call to PreviewDelegatePartitioning, or after\n TfLiteDelegateParams::Prepare returns.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub PreviewDelegatePartitioning: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            nodes_to_replace: *const TfLiteIntArray,
            partition_params_array: *mut *mut TfLiteDelegateParams,
            num_partitions: *mut ::core::ffi::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Returns a TfLiteTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."]
    pub GetTensor: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::core::ffi::c_int,
        ) -> *mut TfLiteTensor,
    >,
    #[doc = " Returns a TfLiteEvalTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."]
    pub GetEvalTensor: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::core::ffi::c_int,
        ) -> *mut TfLiteEvalTensor,
    >,
    #[doc = " Retrieves named metadata buffer from the TFLite model.\n Returns kTfLiteOk if metadata is successfully obtained from the flatbuffer\n Model: that is, there exists a `metadata` entry with given `name` string.\n (see TFLite's schema.fbs).\n The corresponding `buffer` information is populated in `ptr` & `bytes`.\n The data from `ptr` is valid for the lifetime of the Interpreter.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetModelMetadata: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            name: *const ::core::ffi::c_char,
            ptr: *mut *const ::core::ffi::c_char,
            bytes: *mut usize,
        ) -> TfLiteStatus,
    >,
    #[doc = " Retrieves the corresponding TfLiteContext of a subgraph that the given\n subgraph_index points to and switches to the delegate context for that\n subgraph. If an invalid subgraph index is given, returns kTfLiteError.\n\n NOTE: This function is expected to be paired with ReleaseSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub AcquireSubgraphContext: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            subgraph_index: ::core::ffi::c_int,
            acquired_context: *mut *mut TfLiteContext,
        ) -> TfLiteStatus,
    >,
    #[doc = " Releases the subgraph context by switching back to the TFLite kernel\n context for the subgraph that the given subgraph_index points to.\n\n NOTE: This function is expected to be used after AcquireSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub ReleaseSubgraphContext: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            subgraph_index: ::core::ffi::c_int,
        ) -> TfLiteStatus,
    >,
}
#[test]
fn bindgen_test_layout_TfLiteContext() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteContext> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteContext>(),
        200usize,
        concat!("Size of: ", stringify!(TfLiteContext))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tensors_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetExecutionPlan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExecutionPlan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tensors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ResizeTensor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReportError) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReportError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddTensors) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AddTensors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetNodeAndRegistration) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetNodeAndRegistration)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReplaceNodeSubsetsWithDelegateKernels) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReplaceNodeSubsetsWithDelegateKernels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recommended_num_threads) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(recommended_num_threads)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetExternalContext) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExternalContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetExternalContext) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(SetExternalContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allow_fp32_relax_to_fp16) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(allow_fp32_relax_to_fp16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profiler) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(profiler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocatePersistentBuffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocatePersistentBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocateBufferForEval) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocateBufferForEval)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).RequestScratchBufferInArena) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(RequestScratchBufferInArena)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetScratchBuffer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetScratchBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ResizeTensorExplicit) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensorExplicit)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PreviewDelegatePartitioning) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(PreviewDelegatePartitioning)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetTensor) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetTensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetEvalTensor) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetEvalTensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetModelMetadata) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetModelMetadata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AcquireSubgraphContext) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AcquireSubgraphContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReleaseSubgraphContext) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReleaseSubgraphContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOperator {
    _unused: [u8; 0],
}
pub type TfLiteRegistrationExternal = TfLiteOperator;
#[repr(u64)]
#[doc = " The valid values of the `inplace_operator` field in `TfLiteRegistration`.\n This allow an op to signal to the runtime that the same data pointer\n may be passed as an input and output without impacting the result.\n This does not mean that the memory can safely be reused, it is up to the\n runtime to determine this, e.g. if another op consumes the same input or not\n or if an input tensor has sufficient memory allocated to store the output\n data.\n\n Setting these flags authorizes the runtime to set the data pointers of an\n input and output tensor to the same value. In such cases, the memory\n required by the output must be less than or equal to that required by the\n shared input, never greater. If kTfLiteInplaceOpDataUnmodified is set, then\n the runtime can share the same input tensor with multiple operator's\n outputs, provided that kTfLiteInplaceOpDataUnmodified is set for all of\n them. Otherwise, if an input tensor is consumed by multiple operators, it\n may only be shared with the operator which is the last to consume it.\n\n Note that this is a bitmask, so the values should be 1, 2, 4, 8, ...etc."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteInPlaceOp {
    #[doc = " The default value. This indicates that the same data pointer cannot safely\n be passed as an op's input and output."]
    kTfLiteInplaceOpNone = 0,
    #[doc = " This indicates that an op's first output's data is identical to its first\n input's data, for example Reshape."]
    kTfLiteInplaceOpDataUnmodified = 1,
    #[doc = " Setting kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput means\n that InputN may be shared with OutputN instead of with the first output.\n This flag requires one or more of kTfLiteInplaceOpInputNShared to be set."]
    kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput = 2,
    #[doc = " kTfLiteInplaceOpInputNShared indicates that it is safe for an op to share\n InputN's data pointer with an output tensor. If\n kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput is set then\n kTfLiteInplaceOpInputNShared indicates that InputN may be shared\n with OutputN, otherwise kTfLiteInplaceOpInputNShared indicates that InputN\n may be shared with the first output.\n\n Indicates that an op's first input may be shared with the first output\n tensor. kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput has\n no impact on the behavior allowed by this flag."]
    kTfLiteInplaceOpInput0Shared = 4,
    #[doc = " Indicates that an op's second input may be shared with the first output\n if kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput is not set\n or second output if kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput\n is set."]
    kTfLiteInplaceOpInput1Shared = 8,
    #[doc = " Indicates that an op's third input may be shared with the first output\n if kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput is not set\n or third output if kTfLiteInplaceInputCanBeSharedWithCorrespondingOutput\n is\n set."]
    kTfLiteInplaceOpInput2Shared = 16,
    #[doc = " Placeholder to ensure that enum can hold 64 bit values to accommodate\n future fields."]
    kTfLiteInplaceOpMaxValue = 18446744073709551615,
}
#[doc = " The number of shareable inputs supported."]
pub const kTfLiteMaxSharableOpInputs: ::core::ffi::c_int = 3;
#[doc = " `TfLiteRegistration` defines the implementation of an operation\n (a built-in op, custom op, or custom delegate kernel).\n\n It is a struct containing \"methods\" (C function pointers) that will be\n invoked by the TF Lite runtime to evaluate instances of the operation.\n\n See also `TfLiteOperator` which is a more ABI-stable equivalent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration {
    #[doc = " Initializes the op from serialized data.\n Called only *once* for the lifetime of the op, so any one-time allocations\n should be made here (unless they depend on tensor sizes).\n\n * If a built-in op:\n       * `buffer` is the op's params data (TfLiteLSTMParams*).\n       * `length` is zero.\n * If custom op:\n       * `buffer` is the op's `custom_options`.\n       * `length` is the size of the buffer.\n\n Returns a type-punned (i.e. void*) opaque data (e.g. a primitive pointer\n or an instance of a struct).\n\n The returned pointer will be stored with the node in the `user_data`\n field, accessible within prepare and invoke functions below.\n\n NOTE: if the data is already in the desired format, simply implement this\n function to return `nullptr` and implement the free function to be a\n no-op."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::core::ffi::c_char,
            length: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " The pointer `buffer` is the data previously returned by an init\n invocation."]
    pub free: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::core::ffi::c_void),
    >,
    #[doc = " prepare is called when the inputs this node depends on have been resized.\n `context->ResizeTensor()` can be called to request output tensors to be\n resized.\n Can be called multiple times for the lifetime of the op.\n\n Returns `kTfLiteOk` on success."]
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    #[doc = " Execute the node (should read `node->inputs` and output to\n `node->outputs`).\n\n Returns `kTfLiteOk` on success."]
    pub invoke: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    #[doc = " `profiling_string` is called during summarization of profiling information\n in order to group executions together. Providing a value here will cause a\n given op to appear multiple times is the profiling report. This is\n particularly useful for custom ops that can perform significantly\n different calculations depending on their `user-data`."]
    pub profiling_string: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::core::ffi::c_char,
    >,
    #[doc = " Builtin codes. If this kernel refers to a builtin this is the code\n of the builtin. This is so we can do marshaling to other frameworks like\n NN API.\n\n Note: It is the responsibility of the registration binder to set this\n properly."]
    pub builtin_code: i32,
    #[doc = " Custom op name. If the op is a builtin, this will be `null`.\n\n Note: It is the responsibility of the registration binder to set this\n properly.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub custom_name: *const ::core::ffi::c_char,
    #[doc = " The version of the op.\n Note: It is the responsibility of the registration binder to set this\n properly."]
    pub version: ::core::ffi::c_int,
    #[doc = " The external (i.e. ABI-stable) version of `TfLiteRegistration`.\n Since we can't use internal types (such as `TfLiteContext`) for C API to\n maintain ABI stability.  C API user will provide `TfLiteOperator` to\n implement custom ops.  We keep it inside of `TfLiteRegistration` and use\n it to route callbacks properly."]
    pub registration_external: *mut TfLiteOperator,
    #[doc = " Retrieves asynchronous kernel.\n\n If the `async_kernel` field is nullptr, it means the operation described\n by this TfLiteRegistration object does not support asynchronous execution.\n Otherwise, the function that the field points to should only be called for\n delegate kernel nodes, i.e. `node` should be a delegate kernel node\n created by applying a delegate. If the function returns nullptr, that\n means that the underlying delegate does not support asynchronous execution\n for this `node`."]
    pub async_kernel: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            node: *mut TfLiteNode,
        ) -> *mut TfLiteAsyncKernel,
    >,
    #[doc = " Indicates if an operator's output may safely overwrite its inputs.\n See the comments in `TfLiteInPlaceOp`."]
    pub inplace_operator: u64,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteRegistration> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteRegistration>(),
        88usize,
        concat!("Size of: ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteRegistration>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profiling_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).builtin_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registration_external) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(registration_external)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).async_kernel) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(async_kernel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inplace_operator) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(inplace_operator)
        )
    );
}
#[doc = " \\private\n Old version of `TfLiteRegistration` to maintain binary backward\n compatibility.\n The legacy registration type must be a POD struct type whose field types\n must be a prefix of the field types in TfLiteRegistration, and offset of the\n first field in TfLiteRegistration that is not present in the legacy\n registration type must be greater than or equal to the size of the legacy\n registration type.\n\n WARNING: This structure is deprecated / not an official part of the\n API. It should be only used for binary backward compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration_V3 {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::core::ffi::c_char,
            length: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::core::ffi::c_void),
    >,
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub invoke: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub profiling_string: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::core::ffi::c_char,
    >,
    pub builtin_code: i32,
    pub custom_name: *const ::core::ffi::c_char,
    pub version: ::core::ffi::c_int,
    pub registration_external: *mut TfLiteOperator,
    pub async_kernel: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            node: *mut TfLiteNode,
        ) -> *mut TfLiteAsyncKernel,
    >,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration_V3() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteRegistration_V3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteRegistration_V3>(),
        80usize,
        concat!("Size of: ", stringify!(TfLiteRegistration_V3))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteRegistration_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration_V3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profiling_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).builtin_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registration_external) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(registration_external)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).async_kernel) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V3),
            "::",
            stringify!(async_kernel)
        )
    );
}
#[doc = " \\private\n Old version of `TfLiteRegistration` to maintain binary backward\n compatibility.\n The legacy registration type must be a POD struct type whose field types\n must be a prefix of the field types in TfLiteRegistration, and offset of the\n first field in TfLiteRegistration that is not present in the legacy\n registration type must be greater than or equal to the size of the legacy\n registration type.\n\n WARNING: This structure is deprecated / not an official part of the\n API. It should be only used for binary backward compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration_V2 {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::core::ffi::c_char,
            length: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::core::ffi::c_void),
    >,
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub invoke: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub profiling_string: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::core::ffi::c_char,
    >,
    pub builtin_code: i32,
    pub custom_name: *const ::core::ffi::c_char,
    pub version: ::core::ffi::c_int,
    pub registration_external: *mut TfLiteOperator,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration_V2() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteRegistration_V2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteRegistration_V2>(),
        72usize,
        concat!("Size of: ", stringify!(TfLiteRegistration_V2))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteRegistration_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration_V2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profiling_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).builtin_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registration_external) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V2),
            "::",
            stringify!(registration_external)
        )
    );
}
#[doc = " \\private\n Old version of `TfLiteRegistration` to maintain binary backward\n compatibility.\n The legacy registration type must be a POD struct type whose field types\n must be a prefix of the field types in TfLiteRegistration, and offset of the\n first field in TfLiteRegistration that is not present in the legacy\n registration type must be greater than or equal to the size of the legacy\n registration type.\n\n WARNING: This structure is deprecated / not an official part of the\n API. It should be only used for binary backward compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration_V1 {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::core::ffi::c_char,
            length: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::core::ffi::c_void),
    >,
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub invoke: ::core::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    pub profiling_string: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::core::ffi::c_char,
    >,
    pub builtin_code: i32,
    pub custom_name: *const ::core::ffi::c_char,
    pub version: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration_V1() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteRegistration_V1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteRegistration_V1>(),
        64usize,
        concat!("Size of: ", stringify!(TfLiteRegistration_V1))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteRegistration_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration_V1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profiling_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).builtin_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration_V1),
            "::",
            stringify!(version)
        )
    );
}
#[repr(u32)]
#[doc = " The flags used in `TfLiteDelegate`. Note that this is a bitmask, so the\n values should be 1, 2, 4, 8, ...etc."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteDelegateFlags {
    kTfLiteDelegateFlagsNone = 0,
    #[doc = " The flag is set if the delegate can handle dynamic sized tensors.\n For example, the output shape of a `Resize` op with non-constant shape\n can only be inferred when the op is invoked.\n In this case, the Delegate is responsible for calling\n `SetTensorToDynamic` to mark the tensor as a dynamic tensor, and calling\n `ResizeTensor` when invoking the op.\n\n If the delegate isn't capable to handle dynamic tensors, this flag need\n to be set to false."]
    kTfLiteDelegateFlagsAllowDynamicTensors = 1,
    #[doc = " This flag can be used by delegates (that allow dynamic tensors) to ensure\n applicable tensor shapes are automatically propagated in the case of\n tensor resizing. This means that non-dynamic (allocation_type !=\n kTfLiteDynamic) I/O tensors of a delegate kernel will have correct shapes\n before its Prepare() method is called. The runtime leverages TFLite\n builtin ops in the original execution plan to propagate shapes.\n\n A few points to note:\n 1. This requires kTfLiteDelegateFlagsAllowDynamicTensors. If that flag is\n false, this one is redundant since the delegate kernels are re-initialized\n every time tensors are resized.\n 2. Enabling this flag adds some overhead to AllocateTensors(), since extra\n work is required to prepare the original execution plan.\n 3. This flag requires that the original execution plan only have ops with\n valid registrations (and not 'dummy' custom ops like with Flex).\n\n WARNING: This feature is experimental and subject to change."]
    kTfLiteDelegateFlagsRequirePropagatedShapes = 2,
    #[doc = " This flag can be used by delegates to request per-operator profiling. If a\n node is a delegate node, this flag will be checked before profiling. If\n set, then the node will not be profiled. The delegate will then add per\n operator information using `Profiler::EventType::OPERATOR_INVOKE_EVENT`\n and the results will appear in the operator-wise Profiling section and not\n in the Delegate internal section."]
    kTfLiteDelegateFlagsPerOperatorProfiling = 4,
}
#[doc = " WARNING: This is an experimental interface that is subject to change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegate {
    #[doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."]
    pub data_: *mut ::core::ffi::c_void,
    #[doc = " Invoked by `ModifyGraphWithDelegate`. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."]
    pub Prepare: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copy the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for `kTfLiteDynamic` tensors, in which case\n this cannot be null."]
    pub CopyFromBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copy the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."]
    pub CopyToBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Free the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."]
    pub FreeBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            handle: *mut TfLiteBufferHandle,
        ),
    >,
    #[doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."]
    pub flags: i64,
    #[doc = " The opaque delegate builder associated with this object.  If set then the\n TF Lite runtime will give precedence to this field.  E.g. instead of\n invoking `Prepare` via the function pointer inside the `TfLiteDelegate`\n object, the runtime will first check if the corresponding function\n pointer inside `opaque_delegate_builder` is set and if so invoke that.\n\n If this field is non-null, then the `Prepare` field (of the\n `TfLiteDelegate`) should be null."]
    pub opaque_delegate_builder: *mut TfLiteOpaqueDelegateBuilder,
}
#[test]
fn bindgen_test_layout_TfLiteDelegate() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteDelegate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteDelegate>(),
        56usize,
        concat!("Size of: ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prepare) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(Prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CopyFromBufferHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyFromBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CopyToBufferHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyToBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeBufferHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(FreeBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque_delegate_builder) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(opaque_delegate_builder)
        )
    );
}
extern "C" {
    #[doc = " Build a `null` delegate, with all the fields properly set to their default\n values."]
    pub fn TfLiteDelegateCreate() -> TfLiteDelegate;
}
#[doc = " `TfLiteOpaqueDelegateBuilder` is used for constructing\n `TfLiteOpaqueDelegate`, see `TfLiteOpaqueDelegateCreate` in c_api_opaque.h.\n NOTE: This struct is not ABI stable.\n\n For forward source compatibility `TfLiteOpaqueDelegateBuilder` objects\n should be brace-initialized, so that all fields (including any that might be\n added in the future) get zero-initialized.  The purpose of each field is\n exactly the same as with `TfLiteDelegate`.\n\n NOTE: This type is part of the TensorFlow Lite Extension APIs.\n We reserve the right to make changes to this API in future releases,\n potentially including non-backwards-compatible changes, on a different\n schedule than for the other TensorFlow Lite APIs. See\n https://www.tensorflow.org/guide/versions#separate_version_number_for_tensorflow_lite_extension_apis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueDelegateBuilder {
    #[doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."]
    pub data: *mut ::core::ffi::c_void,
    #[doc = " Invoked by ModifyGraphWithDelegate. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."]
    pub Prepare: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::core::ffi::c_void,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copies the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for kTfLiteDynamic tensors, in which case\n this cannot be null."]
    pub CopyFromBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::core::ffi::c_void,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteOpaqueTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copies the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."]
    pub CopyToBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::core::ffi::c_void,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteOpaqueTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Frees the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."]
    pub FreeBufferHandle: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::core::ffi::c_void,
            handle: *mut TfLiteBufferHandle,
        ),
    >,
    #[doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."]
    pub flags: i64,
}
#[test]
fn bindgen_test_layout_TfLiteOpaqueDelegateBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<TfLiteOpaqueDelegateBuilder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TfLiteOpaqueDelegateBuilder>(),
        48usize,
        concat!("Size of: ", stringify!(TfLiteOpaqueDelegateBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<TfLiteOpaqueDelegateBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteOpaqueDelegateBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prepare) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(Prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CopyFromBufferHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(CopyFromBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CopyToBufferHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(CopyToBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeBufferHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(FreeBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn TfLiteOpaqueDelegateCreate(
        opaque_delegate_builder: *const TfLiteOpaqueDelegateBuilder,
    ) -> *mut TfLiteOpaqueDelegate;
}
extern "C" {
    pub fn TfLiteOpaqueDelegateDelete(delegate: *mut TfLiteOpaqueDelegate);
}
extern "C" {
    pub fn TfLiteOpaqueDelegateGetData(
        delegate: *const TfLiteOpaqueDelegate,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Returns a tensor data allocation strategy."]
    pub fn TfLiteTensorGetAllocationStrategy(t: *const TfLiteTensor) -> TfLiteAllocationStrategy;
}
extern "C" {
    #[doc = " Returns how stable a tensor data buffer address is across runs."]
    pub fn TfLiteTensorGetBufferAddressStability(t: *const TfLiteTensor) -> TfLiteRunStability;
}
extern "C" {
    #[doc = " Returns how stable a tensor data values are across runs."]
    pub fn TfLiteTensorGetDataStability(t: *const TfLiteTensor) -> TfLiteRunStability;
}
extern "C" {
    #[doc = " Returns the operation step when the data of a tensor is populated.\n\n Some operations can precompute their results before the evaluation step.\n This makes the data available earlier for subsequent operations."]
    pub fn TfLiteTensorGetDataKnownStep(t: *const TfLiteTensor) -> TfLiteRunStep;
}
extern "C" {
    #[doc = " Returns the operation steop when the shape of a tensor is computed.\n\n Some operations can precompute the shape of their results before the\n evaluation step. This makes the shape available earlier for subsequent\n operations."]
    pub fn TfLiteTensorGetShapeKnownStep(t: *const TfLiteTensor) -> TfLiteRunStep;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum edgetpu_device_type {
    EDGETPU_APEX_PCI = 0,
    EDGETPU_APEX_USB = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edgetpu_device {
    pub type_: edgetpu_device_type,
    pub path: *const ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_edgetpu_device() {
    const UNINIT: ::core::mem::MaybeUninit<edgetpu_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<edgetpu_device>(),
        16usize,
        concat!("Size of: ", stringify!(edgetpu_device))
    );
    assert_eq!(
        ::core::mem::align_of::<edgetpu_device>(),
        8usize,
        concat!("Alignment of ", stringify!(edgetpu_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edgetpu_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edgetpu_device),
            "::",
            stringify!(path)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edgetpu_option {
    pub name: *const ::core::ffi::c_char,
    pub value: *const ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_edgetpu_option() {
    const UNINIT: ::core::mem::MaybeUninit<edgetpu_option> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<edgetpu_option>(),
        16usize,
        concat!("Size of: ", stringify!(edgetpu_option))
    );
    assert_eq!(
        ::core::mem::align_of::<edgetpu_option>(),
        8usize,
        concat!("Alignment of ", stringify!(edgetpu_option))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edgetpu_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edgetpu_option),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn edgetpu_list_devices(num_devices: *mut usize) -> *mut edgetpu_device;
}
extern "C" {
    pub fn edgetpu_free_devices(dev: *mut edgetpu_device);
}
extern "C" {
    pub fn edgetpu_create_delegate(
        type_: edgetpu_device_type,
        name: *const ::core::ffi::c_char,
        options: *const edgetpu_option,
        num_options: usize,
    ) -> *mut TfLiteDelegate;
}
extern "C" {
    pub fn edgetpu_free_delegate(delegate: *mut TfLiteDelegate);
}
extern "C" {
    pub fn edgetpu_verbosity(verbosity: ::core::ffi::c_int);
}
extern "C" {
    pub fn edgetpu_version() -> *const ::core::ffi::c_char;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::core::ffi::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::core::ffi::c_uint,
    pub __high: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::core::ffi::c_int,
    pub __count: ::core::ffi::c_uint,
    pub __owner: ::core::ffi::c_int,
    pub __nusers: ::core::ffi::c_uint,
    pub __kind: ::core::ffi::c_int,
    pub __spins: ::core::ffi::c_short,
    pub __elision: ::core::ffi::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::core::ffi::c_uint,
    pub __writers: ::core::ffi::c_uint,
    pub __wrphase_futex: ::core::ffi::c_uint,
    pub __writers_futex: ::core::ffi::c_uint,
    pub __pad3: ::core::ffi::c_uint,
    pub __pad4: ::core::ffi::c_uint,
    pub __cur_writer: ::core::ffi::c_int,
    pub __shared: ::core::ffi::c_int,
    pub __rwelision: ::core::ffi::c_schar,
    pub __pad1: [::core::ffi::c_uchar; 7usize],
    pub __pad2: ::core::ffi::c_ulong,
    pub __flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::core::ffi::c_uint; 2usize],
    pub __g_size: [::core::ffi::c_uint; 2usize],
    pub __g1_orig_size: ::core::ffi::c_uint,
    pub __wrefs: ::core::ffi::c_uint,
    pub __g_signals: [::core::ffi::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::core::ffi::c_uint;
pub type __thrd_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::core::ffi::c_uint;
pub type pthread_once_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::core::ffi::c_char; 40usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::core::ffi::c_char; 48usize],
    pub __align: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::core::ffi::c_char; 8usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::core::ffi::c_char; 32usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::core::ffi::c_int,
    pub rand_deg: ::core::ffi::c_int,
    pub rand_sep: ::core::ffi::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::core::ffi::c_uint, __buf: *mut random_data) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::core::ffi::c_char,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::core::ffi::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::core::ffi::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::core::ffi::c_ushort; 3usize],
    pub __old_x: [::core::ffi::c_ushort; 3usize],
    pub __c: ::core::ffi::c_ushort,
    pub __init: ::core::ffi::c_ushort,
    pub __a: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::core::ffi::c_long,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::core::ffi::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn alloca(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::core::ffi::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: ::core::ffi::c_int, __arg: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __replace: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearenv() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::core::ffi::c_char,
        __suffixlen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn system(__command: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::core::ffi::c_char,
        __resolved: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(__x: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llabs(__x: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::core::ffi::c_char, __n: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::core::ffi::c_char,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::core::ffi::c_char, __wchar: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::core::ffi::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::core::ffi::c_char,
        __tokens: *const *mut ::core::ffi::c_char,
        __valuep: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteBuiltinOperator {
    kTfLiteBuiltinAdd = 0,
    kTfLiteBuiltinAveragePool2d = 1,
    kTfLiteBuiltinConcatenation = 2,
    kTfLiteBuiltinConv2d = 3,
    kTfLiteBuiltinDepthwiseConv2d = 4,
    kTfLiteBuiltinDepthToSpace = 5,
    kTfLiteBuiltinDequantize = 6,
    kTfLiteBuiltinEmbeddingLookup = 7,
    kTfLiteBuiltinFloor = 8,
    kTfLiteBuiltinFullyConnected = 9,
    kTfLiteBuiltinHashtableLookup = 10,
    kTfLiteBuiltinL2Normalization = 11,
    kTfLiteBuiltinL2Pool2d = 12,
    kTfLiteBuiltinLocalResponseNormalization = 13,
    kTfLiteBuiltinLogistic = 14,
    kTfLiteBuiltinLshProjection = 15,
    kTfLiteBuiltinLstm = 16,
    kTfLiteBuiltinMaxPool2d = 17,
    kTfLiteBuiltinMul = 18,
    kTfLiteBuiltinRelu = 19,
    kTfLiteBuiltinReluN1To1 = 20,
    kTfLiteBuiltinRelu6 = 21,
    kTfLiteBuiltinReshape = 22,
    kTfLiteBuiltinResizeBilinear = 23,
    kTfLiteBuiltinRnn = 24,
    kTfLiteBuiltinSoftmax = 25,
    kTfLiteBuiltinSpaceToDepth = 26,
    kTfLiteBuiltinSvdf = 27,
    kTfLiteBuiltinTanh = 28,
    kTfLiteBuiltinConcatEmbeddings = 29,
    kTfLiteBuiltinSkipGram = 30,
    kTfLiteBuiltinCall = 31,
    kTfLiteBuiltinCustom = 32,
    kTfLiteBuiltinEmbeddingLookupSparse = 33,
    kTfLiteBuiltinPad = 34,
    kTfLiteBuiltinUnidirectionalSequenceRnn = 35,
    kTfLiteBuiltinGather = 36,
    kTfLiteBuiltinBatchToSpaceNd = 37,
    kTfLiteBuiltinSpaceToBatchNd = 38,
    kTfLiteBuiltinTranspose = 39,
    kTfLiteBuiltinMean = 40,
    kTfLiteBuiltinSub = 41,
    kTfLiteBuiltinDiv = 42,
    kTfLiteBuiltinSqueeze = 43,
    kTfLiteBuiltinUnidirectionalSequenceLstm = 44,
    kTfLiteBuiltinStridedSlice = 45,
    kTfLiteBuiltinBidirectionalSequenceRnn = 46,
    kTfLiteBuiltinExp = 47,
    kTfLiteBuiltinTopkV2 = 48,
    kTfLiteBuiltinSplit = 49,
    kTfLiteBuiltinLogSoftmax = 50,
    kTfLiteBuiltinDelegate = 51,
    kTfLiteBuiltinBidirectionalSequenceLstm = 52,
    kTfLiteBuiltinCast = 53,
    kTfLiteBuiltinPrelu = 54,
    kTfLiteBuiltinMaximum = 55,
    kTfLiteBuiltinArgMax = 56,
    kTfLiteBuiltinMinimum = 57,
    kTfLiteBuiltinLess = 58,
    kTfLiteBuiltinNeg = 59,
    kTfLiteBuiltinPadv2 = 60,
    kTfLiteBuiltinGreater = 61,
    kTfLiteBuiltinGreaterEqual = 62,
    kTfLiteBuiltinLessEqual = 63,
    kTfLiteBuiltinSelect = 64,
    kTfLiteBuiltinSlice = 65,
    kTfLiteBuiltinSin = 66,
    kTfLiteBuiltinTransposeConv = 67,
    kTfLiteBuiltinSparseToDense = 68,
    kTfLiteBuiltinTile = 69,
    kTfLiteBuiltinExpandDims = 70,
    kTfLiteBuiltinEqual = 71,
    kTfLiteBuiltinNotEqual = 72,
    kTfLiteBuiltinLog = 73,
    kTfLiteBuiltinSum = 74,
    kTfLiteBuiltinSqrt = 75,
    kTfLiteBuiltinRsqrt = 76,
    kTfLiteBuiltinShape = 77,
    kTfLiteBuiltinPow = 78,
    kTfLiteBuiltinArgMin = 79,
    kTfLiteBuiltinFakeQuant = 80,
    kTfLiteBuiltinReduceProd = 81,
    kTfLiteBuiltinReduceMax = 82,
    kTfLiteBuiltinPack = 83,
    kTfLiteBuiltinLogicalOr = 84,
    kTfLiteBuiltinOneHot = 85,
    kTfLiteBuiltinLogicalAnd = 86,
    kTfLiteBuiltinLogicalNot = 87,
    kTfLiteBuiltinUnpack = 88,
    kTfLiteBuiltinReduceMin = 89,
    kTfLiteBuiltinFloorDiv = 90,
    kTfLiteBuiltinReduceAny = 91,
    kTfLiteBuiltinSquare = 92,
    kTfLiteBuiltinZerosLike = 93,
    kTfLiteBuiltinFill = 94,
    kTfLiteBuiltinFloorMod = 95,
    kTfLiteBuiltinRange = 96,
    kTfLiteBuiltinResizeNearestNeighbor = 97,
    kTfLiteBuiltinLeakyRelu = 98,
    kTfLiteBuiltinSquaredDifference = 99,
    kTfLiteBuiltinMirrorPad = 100,
    kTfLiteBuiltinAbs = 101,
    kTfLiteBuiltinSplitV = 102,
    kTfLiteBuiltinUnique = 103,
    kTfLiteBuiltinCeil = 104,
    kTfLiteBuiltinReverseV2 = 105,
    kTfLiteBuiltinAddN = 106,
    kTfLiteBuiltinGatherNd = 107,
    kTfLiteBuiltinCos = 108,
    kTfLiteBuiltinWhere = 109,
    kTfLiteBuiltinRank = 110,
    kTfLiteBuiltinElu = 111,
    kTfLiteBuiltinReverseSequence = 112,
    kTfLiteBuiltinMatrixDiag = 113,
    kTfLiteBuiltinQuantize = 114,
    kTfLiteBuiltinMatrixSetDiag = 115,
    kTfLiteBuiltinRound = 116,
    kTfLiteBuiltinHardSwish = 117,
    kTfLiteBuiltinIf = 118,
    kTfLiteBuiltinWhile = 119,
    kTfLiteBuiltinNonMaxSuppressionV4 = 120,
    kTfLiteBuiltinNonMaxSuppressionV5 = 121,
    kTfLiteBuiltinScatterNd = 122,
    kTfLiteBuiltinSelectV2 = 123,
    kTfLiteBuiltinDensify = 124,
    kTfLiteBuiltinSegmentSum = 125,
    kTfLiteBuiltinBatchMatmul = 126,
    kTfLiteBuiltinPlaceholderForGreaterOpCodes = 127,
    kTfLiteBuiltinCumsum = 128,
    kTfLiteBuiltinCallOnce = 129,
    kTfLiteBuiltinBroadcastTo = 130,
    kTfLiteBuiltinRfft2d = 131,
    kTfLiteBuiltinConv3d = 132,
    kTfLiteBuiltinImag = 133,
    kTfLiteBuiltinReal = 134,
    kTfLiteBuiltinComplexAbs = 135,
    kTfLiteBuiltinHashtable = 136,
    kTfLiteBuiltinHashtableFind = 137,
    kTfLiteBuiltinHashtableImport = 138,
    kTfLiteBuiltinHashtableSize = 139,
    kTfLiteBuiltinReduceAll = 140,
    kTfLiteBuiltinConv3dTranspose = 141,
    kTfLiteBuiltinVarHandle = 142,
    kTfLiteBuiltinReadVariable = 143,
    kTfLiteBuiltinAssignVariable = 144,
    kTfLiteBuiltinBroadcastArgs = 145,
    kTfLiteBuiltinRandomStandardNormal = 146,
    kTfLiteBuiltinBucketize = 147,
    kTfLiteBuiltinRandomUniform = 148,
    kTfLiteBuiltinMultinomial = 149,
    kTfLiteBuiltinGelu = 150,
    kTfLiteBuiltinDynamicUpdateSlice = 151,
    kTfLiteBuiltinRelu0To1 = 152,
    kTfLiteBuiltinUnsortedSegmentProd = 153,
    kTfLiteBuiltinUnsortedSegmentMax = 154,
    kTfLiteBuiltinUnsortedSegmentSum = 155,
    kTfLiteBuiltinAtan2 = 156,
    kTfLiteBuiltinUnsortedSegmentMin = 157,
    kTfLiteBuiltinSign = 158,
    kTfLiteBuiltinBitcast = 159,
    kTfLiteBuiltinBitwiseXor = 160,
    kTfLiteBuiltinRightShift = 161,
    kTfLiteBuiltinStablehloLogistic = 162,
    kTfLiteBuiltinStablehloAdd = 163,
    kTfLiteBuiltinStablehloDivide = 164,
    kTfLiteBuiltinStablehloMultiply = 165,
    kTfLiteBuiltinStablehloMaximum = 166,
    kTfLiteBuiltinStablehloReshape = 167,
    kTfLiteBuiltinStablehloClamp = 168,
    kTfLiteBuiltinStablehloConcatenate = 169,
    kTfLiteBuiltinStablehloBroadcastInDim = 170,
    kTfLiteBuiltinStablehloConvolution = 171,
    kTfLiteBuiltinStablehloSlice = 172,
    kTfLiteBuiltinStablehloCustomCall = 173,
    kTfLiteBuiltinStablehloReduce = 174,
    kTfLiteBuiltinStablehloAbs = 175,
    kTfLiteBuiltinStablehloAnd = 176,
    kTfLiteBuiltinStablehloCosine = 177,
    kTfLiteBuiltinStablehloExponential = 178,
    kTfLiteBuiltinStablehloFloor = 179,
    kTfLiteBuiltinStablehloLog = 180,
    kTfLiteBuiltinStablehloMinimum = 181,
    kTfLiteBuiltinStablehloNegate = 182,
    kTfLiteBuiltinStablehloOr = 183,
    kTfLiteBuiltinStablehloPower = 184,
    kTfLiteBuiltinStablehloRemainder = 185,
    kTfLiteBuiltinStablehloRsqrt = 186,
    kTfLiteBuiltinStablehloSelect = 187,
    kTfLiteBuiltinStablehloSubtract = 188,
    kTfLiteBuiltinStablehloTanh = 189,
    kTfLiteBuiltinStablehloScatter = 190,
    kTfLiteBuiltinStablehloCompare = 191,
    kTfLiteBuiltinStablehloConvert = 192,
    kTfLiteBuiltinStablehloDynamicSlice = 193,
    kTfLiteBuiltinStablehloDynamicUpdateSlice = 194,
    kTfLiteBuiltinStablehloPad = 195,
    kTfLiteBuiltinStablehloIota = 196,
    kTfLiteBuiltinStablehloDotGeneral = 197,
    kTfLiteBuiltinStablehloReduceWindow = 198,
    kTfLiteBuiltinStablehloSort = 199,
    kTfLiteBuiltinStablehloWhile = 200,
    kTfLiteBuiltinStablehloGather = 201,
    kTfLiteBuiltinStablehloTranspose = 202,
    kTfLiteBuiltinDilate = 203,
    kTfLiteBuiltinStablehloRngBitGenerator = 204,
    kTfLiteBuiltinReduceWindow = 205,
    kTfLiteBuiltinStablehloComposite = 206,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteExecutionTask {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Enum tag for specifying whether a tensor is the input or output to the\n model."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteIoType {
    kTfLiteIoTypeUnknown = 0,
    kTfLiteIoTypeInput = 1,
    kTfLiteIoTypeOutput = 2,
}
extern "C" {
    pub fn TfLiteOperatorCreate(
        builtin_code: TfLiteBuiltinOperator,
        custom_name: *const ::core::ffi::c_char,
        version: ::core::ffi::c_int,
    ) -> *mut TfLiteOperator;
}
extern "C" {
    pub fn TfLiteOperatorDelete(registration: *mut TfLiteOperator);
}
extern "C" {
    pub fn TfLiteOperatorGetBuiltInCode(
        registration: *const TfLiteOperator,
    ) -> TfLiteBuiltinOperator;
}
extern "C" {
    #[doc = " Returns the custom name of the provided 'registration'. The returned pointer\n will be non-null iff the op is a custom op.\n"]
    pub fn TfLiteOperatorGetCustomName(
        registration: *const TfLiteOperator,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the OP version of the provided external 'registration'.  Return -1\n in case of error, or if the provided address is null.\n"]
    pub fn TfLiteOperatorGetVersion(registration: *const TfLiteOperator) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn TfLiteOperatorSetInit(
        registration: *mut TfLiteOperator,
        init: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                buffer: *const ::core::ffi::c_char,
                length: usize,
            ) -> *mut ::core::ffi::c_void,
        >,
    );
}
extern "C" {
    pub fn TfLiteOperatorSetFree(
        registration: *mut TfLiteOperator,
        free: ::core::option::Option<
            unsafe extern "C" fn(context: *mut TfLiteOpaqueContext, data: *mut ::core::ffi::c_void),
        >,
    );
}
extern "C" {
    pub fn TfLiteOperatorSetPrepare(
        registration: *mut TfLiteOperator,
        prepare: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    pub fn TfLiteOperatorSetInvoke(
        registration: *mut TfLiteOperator,
        invoke: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the async kernel accessor callback for the registration.\n\n The callback is called to retrieve the async kernel if the delegate supports\n it. If the delegate does not support async execution, either this function\n should not be called, or `async_kernel` needs to be nullptr.\n `node` is the delegate TfLiteNode created by `ModifyGraphWithDelegate`.\n Please refer `async_kernel` of `TfLiteRegistration` for the detail.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteOperatorSetAsyncKernel(
        registration: *mut TfLiteOperator,
        async_kernel: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> *mut TfLiteAsyncKernel,
        >,
    );
}
extern "C" {
    #[doc = " Sets the inplace_operator field of the external registration.\n\n This is a bitmask. Please refer to `inplace_operator` field of\n `TfLiteRegistration` for details.\n"]
    pub fn TfLiteOperatorSetInplaceOperator(
        registration: *mut TfLiteOperator,
        inplace_operator: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreterOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSignatureRunner {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " The TensorFlow Lite Runtime version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the (potentially dynamically loaded) TF Lite Runtime library.\n TensorFlow Lite uses semantic versioning, and the return value should be\n in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.12.0\" or \"2.13.0-rc2\"."]
    pub fn TfLiteVersion() -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " The TensorFlow Lite Extension APIs version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the TF Lite Extension APIs supported by the (potentially\n dynamically loaded) TF Lite Runtime library.  The TF Lite \"Extension APIs\"\n are the APIs for extending TF Lite with custom ops and delegates.\n More specifically, this version number covers the (non-experimental)\n functionality documented in the following header files:\n\n   * lite/c/c_api_opaque.h\n   * lite/c/common.h\n   * lite/c/builtin_op_data.h\n   * lite/builtin_ops.h\n\n This version number uses semantic versioning, and the return value should\n be in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.14.0\" or \"2.15.0-rc2\"."]
    pub fn TfLiteExtensionApisVersion() -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " The supported TensorFlow Lite model file Schema version.\n\n Returns the (major) version number of the Schema used for model\n files that is supported by the (potentially dynamically loaded)\n TensorFlow Lite Runtime.\n\n Model files using schema versions different to this may not be supported by\n the current version of the TF Lite Runtime."]
    pub fn TfLiteSchemaVersion() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns a model from the provided buffer, or null on failure.\n\n \\note The caller retains ownership of the `model_data` buffer and should\n ensure that the lifetime of the `model_data` buffer must be at least as long\n as the lifetime of the `TfLiteModel` and of any `TfLiteInterpreter` objects\n created from that `TfLiteModel`, and furthermore the contents of the\n `model_data` buffer must not be modified during that time.\""]
    pub fn TfLiteModelCreate(
        model_data: *const ::core::ffi::c_void,
        model_size: usize,
    ) -> *mut TfLiteModel;
}
extern "C" {
    #[doc = " Same as `TfLiteModelCreate` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteModelCreateWithErrorReporter(
        model_data: *const ::core::ffi::c_void,
        model_size: usize,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::core::ffi::c_void,
                format: *const ::core::ffi::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut TfLiteModel;
}
extern "C" {
    #[doc = " Returns a model from the provided file, or null on failure.\n\n \\note The file's contents must not be modified during the lifetime of the\n `TfLiteModel` or of any `TfLiteInterpreter` objects created from that\n `TfLiteModel`."]
    pub fn TfLiteModelCreateFromFile(model_path: *const ::core::ffi::c_char) -> *mut TfLiteModel;
}
extern "C" {
    #[doc = " Same as `TfLiteModelCreateFromFile` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteModelCreateFromFileWithErrorReporter(
        model_path: *const ::core::ffi::c_char,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::core::ffi::c_void,
                format: *const ::core::ffi::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut TfLiteModel;
}
extern "C" {
    #[doc = " Destroys the model instance."]
    pub fn TfLiteModelDelete(model: *mut TfLiteModel);
}
extern "C" {
    #[doc = " Returns a new interpreter options instances."]
    pub fn TfLiteInterpreterOptionsCreate() -> *mut TfLiteInterpreterOptions;
}
extern "C" {
    #[doc = " Creates and returns a shallow copy of an options object.\n\n The caller is responsible for calling `TfLiteInterpreterOptionsDelete` to\n deallocate the object pointed to by the returned pointer."]
    pub fn TfLiteInterpreterOptionsCopy(
        from: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreterOptions;
}
extern "C" {
    #[doc = " Destroys the interpreter options instance."]
    pub fn TfLiteInterpreterOptionsDelete(options: *mut TfLiteInterpreterOptions);
}
extern "C" {
    #[doc = " Sets the number of CPU threads to use for the interpreter."]
    pub fn TfLiteInterpreterOptionsSetNumThreads(
        options: *mut TfLiteInterpreterOptions,
        num_threads: i32,
    );
}
extern "C" {
    #[doc = " Adds a delegate to be applied during `TfLiteInterpreter` creation.\n\n If delegate application fails, interpreter creation will also fail with an\n associated error logged.\n\n \\note The caller retains ownership of the delegate and should ensure that it\n remains valid for the duration of any created interpreter's lifetime.\n\n If you are NOT using \"TensorFlow Lite in Play Services\", and NOT building\n with `TFLITE_WITH_STABLE_ABI` or `TFLITE_USE_OPAQUE_DELEGATE` macros\n enabled, it is possible to pass a `TfLiteDelegate*` rather than a\n `TfLiteOpaqueDelegate*` to this function, since in those cases,\n `TfLiteOpaqueDelegate` is just a typedef alias for `TfLiteDelegate`.\n This is for compatibility with existing source code\n and existing delegates.  For new delegates, it is recommended to\n use `TfLiteOpaqueDelegate` rather than `TfLiteDelegate`.  (See\n `TfLiteOpaqueDelegate` in tensorflow/lite/core/c/c_api_types.h.)"]
    pub fn TfLiteInterpreterOptionsAddDelegate(
        options: *mut TfLiteInterpreterOptions,
        delegate: *mut TfLiteOpaqueDelegate,
    );
}
extern "C" {
    #[doc = " Sets a custom error reporter for interpreter execution.\n\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteInterpreterOptionsSetErrorReporter(
        options: *mut TfLiteInterpreterOptions,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::core::ffi::c_void,
                format: *const ::core::ffi::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Adds an op registration to be applied during `TfLiteInterpreter` creation.\n\n The `TfLiteOperator` object is needed to implement custom op of\n TFLite Interpreter via C API. Calling this function ensures that any\n `TfLiteInterpreter` created with the specified `options` can execute models\n that use the custom operator specified in `registration`.\n Please refer https://www.tensorflow.org/lite/guide/ops_custom for custom op\n support.\n \\note The caller retains ownership of the TfLiteOperator object\n and should ensure that it remains valid for the duration of any created\n interpreter's lifetime.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsAddOperator(
        options: *mut TfLiteInterpreterOptions,
        registration: *mut TfLiteOperator,
    );
}
extern "C" {
    #[doc = " Enables users to cancel in-flight invocations with\n `TfLiteInterpreterCancel`.\n\n By default it is disabled and calling to `TfLiteInterpreterCancel` will\n return kTfLiteError. See `TfLiteInterpreterCancel`."]
    pub fn TfLiteInterpreterOptionsEnableCancellation(
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns a new interpreter using the provided model and options, or null on\n failure.\n\n * `model` must be a valid model instance. The caller retains ownership of\n   the object, and may destroy it (via TfLiteModelDelete) immediately after\n   creating the interpreter.  However, if the TfLiteModel was allocated with\n   TfLiteModelCreate, then the `model_data` buffer that was passed to\n   TfLiteModelCreate must outlive the lifetime of the TfLiteInterpreter\n   object that this function returns, and must not be modified during that\n   time; and if the TfLiteModel was allocated with TfLiteModelCreateFromFile,\n   then the contents of the model file must not be modified during the\n   lifetime of the TfLiteInterpreter object that this function returns.\n * `optional_options` may be null. The caller retains ownership of the\n   object, and can safely destroy it (via TfLiteInterpreterOptionsDelete)\n   immediately after creating the interpreter.\n\n \\note The client *must* explicitly allocate tensors before attempting to\n access input tensor data or invoke the interpreter."]
    pub fn TfLiteInterpreterCreate(
        model: *const TfLiteModel,
        optional_options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter;
}
extern "C" {
    #[doc = " Destroys the interpreter."]
    pub fn TfLiteInterpreterDelete(interpreter: *mut TfLiteInterpreter);
}
extern "C" {
    #[doc = " Returns the number of input tensors associated with the model."]
    pub fn TfLiteInterpreterGetInputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
}
extern "C" {
    #[doc = " Returns a pointer to an array of input tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetInputTensorCount`.\n\n Typically the input tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetInputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub fn TfLiteInterpreterInputTensorIndices(
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the tensor associated with the input index.\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)"]
    pub fn TfLiteInterpreterGetInputTensor(
        interpreter: *const TfLiteInterpreter,
        input_index: i32,
    ) -> *mut TfLiteTensor;
}
extern "C" {
    #[doc = " Resizes the specified input tensor.\n\n \\note After a resize, the client *must* explicitly allocate tensors before\n attempting to access the resized tensor data or invoke the interpreter.\n\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)\n\n This function makes a copy of the input dimensions, so the client can safely\n deallocate `input_dims` immediately after this function returns."]
    pub fn TfLiteInterpreterResizeInputTensor(
        interpreter: *mut TfLiteInterpreter,
        input_index: i32,
        input_dims: *const ::core::ffi::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Updates allocations for all tensors, resizing dependent tensors using the\n specified input tensor dimensionality.\n\n This is a relatively expensive operation, and need only be called after\n creating the graph and/or resizing any inputs."]
    pub fn TfLiteInterpreterAllocateTensors(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Runs inference for the loaded graph.\n\n Before calling this function, the caller should first invoke\n TfLiteInterpreterAllocateTensors() and should also set the values for the\n input tensors.  After successfully calling this function, the values for the\n output tensors will be set.\n\n \\note It is possible that the interpreter is not in a ready state to\n evaluate (e.g., if AllocateTensors() hasn't been called, or if a\n ResizeInputTensor() has been performed without a subsequent call to\n AllocateTensors()).\n\n   If the (experimental!) delegate fallback option was enabled in the\n   interpreter options, then the interpreter will automatically fall back to\n   not using any delegates if execution with delegates fails. For details,\n   see TfLiteInterpreterOptionsSetEnableDelegateFallback in\n   c_api_experimental.h.\n\n Returns one of the following status codes:\n  - kTfLiteOk: Success. Output is valid.\n  - kTfLiteDelegateError: Execution with delegates failed, due to a problem\n    with the delegate(s). If fallback was not enabled, output is invalid.\n    If fallback was enabled, this return value indicates that fallback\n    succeeded, the output is valid, and all delegates previously applied to\n    the interpreter have been undone.\n  - kTfLiteApplicationError: Same as for kTfLiteDelegateError, except that\n    the problem was not with the delegate itself, but rather was\n    due to an incompatibility between the delegate(s) and the\n    interpreter or model.\n  - kTfLiteError: Unexpected/runtime failure. Output is invalid."]
    pub fn TfLiteInterpreterInvoke(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the number of output tensors associated with the model."]
    pub fn TfLiteInterpreterGetOutputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
}
extern "C" {
    #[doc = " Returns a pointer to an array of output tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetOutputTensorCount`.\n\n Typically the output tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetOutputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub fn TfLiteInterpreterOutputTensorIndices(
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the tensor associated with the output index.\n REQUIRES: 0 <= output_index < TfLiteInterpreterGetOutputTensorCount(tensor)\n\n \\note The shape and underlying data buffer for output tensors may be not\n be available until after the output tensor has been both sized and\n allocated.\n In general, best practice is to interact with the output tensor *after*\n calling TfLiteInterpreterInvoke()."]
    pub fn TfLiteInterpreterGetOutputTensor(
        interpreter: *const TfLiteInterpreter,
        output_index: i32,
    ) -> *const TfLiteTensor;
}
extern "C" {
    #[doc = " Returns modifiable access to the tensor that corresponds to the\n specified `index` and is associated with the provided `interpreter`.\n\n This requires the `index` to be between 0 and N - 1, where N is the\n number of tensors in the model.\n\n Typically the tensors associated with the `interpreter` would be set during\n the `interpreter` initialization, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `AddTensors` on the interpreter invalidate the returned pointer.\n\n Note the difference between this function and\n `TfLiteInterpreterGetInputTensor` (or `TfLiteInterpreterGetOutputTensor` for\n that matter): `TfLiteInterpreterGetTensor` takes an index into the array of\n all tensors associated with the `interpreter`'s model, whereas\n `TfLiteInterpreterGetInputTensor` takes an index into the array of input\n tensors.\n\n The ownership of the tensor remains with the TFLite runtime, meaning the\n caller should not deallocate the pointer."]
    pub fn TfLiteInterpreterGetTensor(
        interpreter: *const TfLiteInterpreter,
        index: ::core::ffi::c_int,
    ) -> *mut TfLiteTensor;
}
extern "C" {
    #[doc = " Tries to cancel any in-flight invocation.\n\n \\note This only cancels `TfLiteInterpreterInvoke` calls that happen before\n calling this and it does not cancel subsequent invocations.\n \\note Calling this function will also cancel any in-flight invocations of\n SignatureRunners constructed from this interpreter.\n Non-blocking and thread safe.\n\n Returns kTfLiteError if cancellation is not enabled via\n `TfLiteInterpreterOptionsEnableCancellation`."]
    pub fn TfLiteInterpreterCancel(interpreter: *const TfLiteInterpreter) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the number of signatures defined in the model."]
    pub fn TfLiteInterpreterGetSignatureCount(interpreter: *const TfLiteInterpreter) -> i32;
}
extern "C" {
    #[doc = " Returns the key of the Nth signature in the model, where N is specified as\n `signature_index`.\n\n NOTE: The lifetime of the returned key is the same as (and depends on) the\n lifetime of `interpreter`."]
    pub fn TfLiteInterpreterGetSignatureKey(
        interpreter: *const TfLiteInterpreter,
        signature_index: i32,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a new signature runner using the provided interpreter and signature\n key, or nullptr on failure.\n\n NOTE: `signature_key` is a null-terminated C string that must match the\n key of a signature in the interpreter's model.\n\n NOTE: The returned signature runner should be destroyed, by calling\n TfLiteSignatureRunnerDelete(), before the interpreter is destroyed."]
    pub fn TfLiteInterpreterGetSignatureRunner(
        interpreter: *const TfLiteInterpreter,
        signature_key: *const ::core::ffi::c_char,
    ) -> *mut TfLiteSignatureRunner;
}
extern "C" {
    #[doc = " Returns the number of inputs associated with a signature."]
    pub fn TfLiteSignatureRunnerGetInputCount(
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the (null-terminated) name of the Nth input in a signature, where N\n is specified as `input_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub fn TfLiteSignatureRunnerGetInputName(
        signature_runner: *const TfLiteSignatureRunner,
        input_index: i32,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Resizes the input tensor identified as `input_name` to be the dimensions\n specified by `input_dims` and `input_dims_size`. Only unknown dimensions can\n be resized with this function. Unknown dimensions are indicated as `-1` in\n the `dims_signature` attribute of a TfLiteTensor.\n\n Returns status of failure or success. Note that this doesn't actually resize\n any existing buffers. A call to TfLiteSignatureRunnerAllocateTensors() is\n required to change the tensor input buffer.\n\n NOTE: This function is similar to TfLiteInterpreterResizeInputTensorStrict()\n and not TfLiteInterpreterResizeInputTensor().\n\n NOTE: `input_name` must match the name of an input in the signature.\n\n NOTE: This function makes a copy of the input dimensions, so the caller can\n safely deallocate `input_dims` immediately after this function returns."]
    pub fn TfLiteSignatureRunnerResizeInputTensor(
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::core::ffi::c_char,
        input_dims: *const ::core::ffi::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Updates allocations for tensors associated with a signature and resizes\n dependent tensors using the specified input tensor dimensionality.\n This is a relatively expensive operation and hence should only be called\n after initializing the signature runner object and/or resizing any inputs."]
    pub fn TfLiteSignatureRunnerAllocateTensors(
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the input tensor identified by `input_name` in the given signature.\n Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub fn TfLiteSignatureRunnerGetInputTensor(
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::core::ffi::c_char,
    ) -> *mut TfLiteTensor;
}
extern "C" {
    #[doc = " Runs inference on a given signature.\n\n Before calling this function, the caller should first invoke\n TfLiteSignatureRunnerAllocateTensors() and should also set the values for\n the input tensors. After successfully calling this function, the values for\n the output tensors will be set."]
    pub fn TfLiteSignatureRunnerInvoke(
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the number of output tensors associated with the signature."]
    pub fn TfLiteSignatureRunnerGetOutputCount(
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the (null-terminated) name of the Nth output in a signature, where\n N is specified as `output_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub fn TfLiteSignatureRunnerGetOutputName(
        signature_runner: *const TfLiteSignatureRunner,
        output_index: i32,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the output tensor identified by `output_name` in the given\n signature. Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub fn TfLiteSignatureRunnerGetOutputTensor(
        signature_runner: *const TfLiteSignatureRunner,
        output_name: *const ::core::ffi::c_char,
    ) -> *const TfLiteTensor;
}
extern "C" {
    #[doc = " Returns the type of a tensor element."]
    pub fn TfLiteTensorType(tensor: *const TfLiteTensor) -> TfLiteType;
}
extern "C" {
    #[doc = " Returns the number of dimensions that the tensor has.  Returns -1 in case\n the 'opaque_tensor' does not have its dimensions property set."]
    pub fn TfLiteTensorNumDims(tensor: *const TfLiteTensor) -> i32;
}
extern "C" {
    #[doc = " Returns the length of the tensor in the \"dim_index\" dimension.\n REQUIRES: 0 <= dim_index < TFLiteTensorNumDims(tensor)"]
    pub fn TfLiteTensorDim(tensor: *const TfLiteTensor, dim_index: i32) -> i32;
}
extern "C" {
    #[doc = " Returns the size of the underlying data in bytes."]
    pub fn TfLiteTensorByteSize(tensor: *const TfLiteTensor) -> usize;
}
extern "C" {
    #[doc = " Returns a pointer to the underlying data buffer.\n\n \\note The result may be null if tensors have not yet been allocated, e.g.,\n if the Tensor has just been created or resized and `TfLiteAllocateTensors()`\n has yet to be called, or if the output tensor is dynamically sized and the\n interpreter hasn't been invoked."]
    pub fn TfLiteTensorData(tensor: *const TfLiteTensor) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Returns the (null-terminated) name of the tensor."]
    pub fn TfLiteTensorName(tensor: *const TfLiteTensor) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the parameters for asymmetric quantization. The quantization\n parameters are only valid when the tensor type is `kTfLiteUInt8` and the\n `scale != 0`. Quantized values can be converted back to float using:\n    real_value = scale * (quantized_value - zero_point);"]
    pub fn TfLiteTensorQuantizationParams(tensor: *const TfLiteTensor) -> TfLiteQuantizationParams;
}
extern "C" {
    #[doc = " Copies from the provided input buffer into the tensor's buffer.\n REQUIRES: input_data_size == TfLiteTensorByteSize(tensor)"]
    pub fn TfLiteTensorCopyFromBuffer(
        tensor: *mut TfLiteTensor,
        input_data: *const ::core::ffi::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Copies to the provided output buffer from the tensor's buffer.\n REQUIRES: output_data_size == TfLiteTensorByteSize(tensor)"]
    pub fn TfLiteTensorCopyToBuffer(
        output_tensor: *const TfLiteTensor,
        output_data: *mut ::core::ffi::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Destroys the signature runner."]
    pub fn TfLiteSignatureRunnerDelete(signature_runner: *mut TfLiteSignatureRunner);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBackendBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates an empty TfLiteBackendBuffer that does not contain any hardware\n buffers object.\n Returned object is owned by the caller."]
    pub fn TfLiteBackendBufferCreate() -> *mut TfLiteBackendBuffer;
}
extern "C" {
    #[doc = " Destroys a TfLiteBackendBuffer.\n Calling this function will not release the buffer object stored underneath."]
    pub fn TfLiteBackendBufferDelete(buf: *mut TfLiteBackendBuffer);
}
extern "C" {
    #[doc = " Stores a type puned buffer object to TfLiteBackendBuffer.\n `buf` will not own or control the lifecycle of `ptr`.\n Callers needs to ensure lifetime of *ptr exceeds `buf`."]
    pub fn TfLiteBackendBufferSetPtr(buf: *mut TfLiteBackendBuffer, ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " Retrieves the buffer object from TfLiteBackendBuffer.\n Callers can use TfLiteAttributeMap buffer type name to interpret returned\n pointer."]
    pub fn TfLiteBackendBufferGetPtr(buf: *const TfLiteBackendBuffer) -> *mut ::core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSynchronization {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates an empty TfLiteSynchronization.\n Returned object is owned by the caller."]
    pub fn TfLiteSynchronizationCreate() -> *mut TfLiteSynchronization;
}
extern "C" {
    #[doc = " Destroys a TfLiteSynchronization.\n Calling this function will not release the synchronization object stored."]
    pub fn TfLiteSynchronizationDelete(sync: *mut TfLiteSynchronization);
}
extern "C" {
    #[doc = " Stores a type-punned pointer to a platform-specific synchronization object.\n `sync` will not own or control the lifecycle of `ptr`.\n Callers needs to ensure lifetime of *ptr exceeds `sync`."]
    pub fn TfLiteSynchronizationSetPtr(
        sync: *mut TfLiteSynchronization,
        ptr: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Retrieves the sync object from TfLiteSynchronization.\n Callers can use TfLiteAttributeMap sync type name to interpret returned\n pointer."]
    pub fn TfLiteSynchronizationGetPtr(
        sync: *const TfLiteSynchronization,
    ) -> *mut ::core::ffi::c_void;
}
#[repr(u32)]
#[doc = " Type of the attribute map.\n An attribute map can either describe the properties of backend buffers\n or synchronizations.\n The value of the TfLiteAttrMapType determines the interpretation of\n attribute keys. See comments below."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteAttrMapType {
    #[doc = " Unknown type."]
    kTfLiteAttrMapTypeUnknown = 0,
    #[doc = " The attributes describes a platform-specific hardware buffer object (e.g.\n AHardwareBuffer for Android).\n Keys are of TfLiteBufferAttrKey type."]
    kTfLiteAttrMapTypeBuffer = 1,
    #[doc = " The attributes describes a sync object (e.g. a file descriptor as sync\n fence).\n Keys are of TfLiteSynchronizationAttrKey type."]
    kTfLiteAttrMapTypeSync = 2,
}
#[repr(u32)]
#[doc = " General hardware buffer attribute keys that are recognizable by TFLite."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteBufferAttrKey {
    kTfLiteBufferAttrKeyUnknown = 0,
    #[doc = " Backing buffer resource. const char*\n e.g. \"AHardwareBuffer\"."]
    kTfLiteBufferAttrKeyResourceTypeName = 1,
    #[doc = " Buffer alignment, size_t"]
    kTfLiteBufferAttrKeyAlignment = 2,
    #[doc = " Buffer padding, size_t"]
    kTfLiteBufferAttrKeyPadding = 3,
    #[doc = " Buffer offset, size_t"]
    kTfLiteBufferAttrKeyOffset = 4,
    #[doc = " Buffer size (padded size if applicable), size_t"]
    kTfLiteBufferAttrKeySize = 5,
    #[doc = " Buffer current host coherency state, bool"]
    kTfLiteBufferAttrKeyCurrentHostCoherencyState = 6,
    #[doc = " Buffer preferred host coherency state, bool"]
    kTfLiteBufferAttrKeyPreferredHostCoherencyState = 7,
    #[doc = " Buffer current host cache state, bool"]
    kTfLiteBufferAttrKeyCurrentHostCacheState = 8,
    #[doc = " Buffer preferred cache state, bool"]
    kTfLiteBufferAttrKeyPreferredHostCacheState = 9,
}
#[repr(u32)]
#[doc = " General synchronization attribute keys that are recognizable by TFLite."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteSynchronizationAttrKey {
    kTfLiteSynchronizationAttrKeyUnknown = 0,
    #[doc = " Synchronization type name. const char*\n e.g. \"sync_fence_fd\""]
    kTfLiteSynchronizationAttrKeyObjectTypeName = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAttributeMap {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates an attribute map.\n `type` argument determines what the attribute map is describing\n (e.g. buffer, or sync object).\n Returned object is owned by the caller."]
    pub fn TfLiteAttributeMapCreate(type_: TfLiteAttrMapType) -> *mut TfLiteAttributeMap;
}
extern "C" {
    #[doc = " Destroys the attribute map.\n Do nothing if `attrs` is nullptr."]
    pub fn TfLiteAttributeMapDelete(attrs: *mut TfLiteAttributeMap);
}
extern "C" {
    #[doc = " Returns true if `attrs` is a buffer attribute map.\n If `attrs` is nullptr, returns false."]
    pub fn TfLiteAttributeMapIsBufferAttributeMap(attrs: *const TfLiteAttributeMap) -> bool;
}
extern "C" {
    #[doc = " Returns true if `attrs` is a sync object attribute map.\n If `attrs` is nullptr, returns false."]
    pub fn TfLiteAttributeMapIsSyncAttributeMap(attrs: *const TfLiteAttributeMap) -> bool;
}
extern "C" {
    #[doc = " Copies all attributes from `src` to `dst`. Any existing attributes in `dst`\n will be cleared.\n If `src` or `dst` is null, does nothing."]
    pub fn TfLiteAttributeMapCopy(src: *const TfLiteAttributeMap, dst: *mut TfLiteAttributeMap);
}
extern "C" {
    #[doc = " Gets the int buffer attribute value for the given `key`.\n Returns false if the key is not set, `attrs` is not a buffer attribute map,\n or the value is not of type `size_t`."]
    pub fn TfLiteAttributeMapGetSizeTBufferAttr(
        attrs: *const TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Sets the `key` buffer attribute as `val`.\n Returns false if `attrs` is not a buffer attribute map."]
    pub fn TfLiteAttributeMapSetSizeTBufferAttr(
        attrs: *mut TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the C string buffer attribute value for the given `key`.\n Returns false if the key is not set, `attrs` is not a buffer attribute map,\n or the value is not of type `size_t`.\n Returned C string's lifespan is determined by the setter of that value.\n Neither `attrs` nor the caller maintains the lifespan of the string."]
    pub fn TfLiteAttributeMapGetStringBufferAttr(
        attrs: *const TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Sets the `key` buffer attribute as `val`.\n Returns false if `attrs` is not a buffer attribute map.\n `attrs` does not own the `val` C string."]
    pub fn TfLiteAttributeMapSetStringBufferAttr(
        attrs: *mut TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the bool buffer attribute value for the given `key`.\n Returns false if the key is not set, `attrs` is not a buffer attribute map,\n or the value is not of type `bool`."]
    pub fn TfLiteAttributeMapGetBoolBufferAttr(
        attrs: *const TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Sets the `key` buffer attribute as `val`.\n Returns false if `attrs` is not a sync attribute map.\n `attrs` does not own the `val` C string."]
    pub fn TfLiteAttributeMapSetBoolBufferAttr(
        attrs: *mut TfLiteAttributeMap,
        key: TfLiteBufferAttrKey,
        val: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the C string synchronization attribute value for the given `key`.\n Returns false if the key is not set, `attrs` is not a sync attribute map,\n or the value is not of type `size_t`.\n Returned C string's lifespan is determined by the setter of that value.\n Neither `attrs` nor the caller maintains the lifespan of the string."]
    pub fn TfLiteAttributeMapGetStringSyncAttr(
        attrs: *const TfLiteAttributeMap,
        key: TfLiteSynchronizationAttrKey,
        val: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Sets the `key` buffer attribute as `val`.\n Returns false if `attrs` is not a sync attribute map.\n `attrs` does not own the `val` C string."]
    pub fn TfLiteAttributeMapSetStringSyncAttr(
        attrs: *mut TfLiteAttributeMap,
        key: TfLiteSynchronizationAttrKey,
        val: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapGetIntAttr(
        attrs: *const TfLiteAttributeMap,
        key: u32,
        val: *mut ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetIntAttr(
        attrs: *mut TfLiteAttributeMap,
        key: u32,
        val: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn TfLiteAttributeMapGetCustomIntAttr(
        attrs: *const TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetCustomIntAttr(
        attrs: *mut TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn TfLiteAttributeMapGetSizeTAttr(
        attrs: *const TfLiteAttributeMap,
        key: u32,
        val: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetSizeTAttr(attrs: *mut TfLiteAttributeMap, key: u32, val: usize);
}
extern "C" {
    pub fn TfLiteAttributeMapGetCustomSizeTAttr(
        attrs: *const TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetCustomSizeTAttr(
        attrs: *mut TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: usize,
    );
}
extern "C" {
    pub fn TfLiteAttributeMapGetStringAttr(
        attrs: *const TfLiteAttributeMap,
        key: u32,
        val: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetStringAttr(
        attrs: *mut TfLiteAttributeMap,
        key: u32,
        val: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn TfLiteAttributeMapGetCustomStringAttr(
        attrs: *const TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetCustomStringAttr(
        attrs: *mut TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn TfLiteAttributeMapGetBoolAttr(
        attrs: *const TfLiteAttributeMap,
        key: u32,
        val: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetBoolAttr(attrs: *mut TfLiteAttributeMap, key: u32, val: bool);
}
extern "C" {
    pub fn TfLiteAttributeMapGetCustomBoolAttr(
        attrs: *const TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn TfLiteAttributeMapSetCustomBoolAttr(
        attrs: *mut TfLiteAttributeMap,
        key: *const ::core::ffi::c_char,
        val: bool,
    );
}
extern "C" {
    #[doc = " Creates an async kernel to be initialized.\n `kernel_data` is the arbitrary data for identifying the async kernel itself\n and can be retrieved using `TfLiteAsyncKernelGetKernelData`.\n NOTE: TfLiteAsyncKernel does not own `kernel_data` and callers should\n ensure `kernel_data` out-lives the returned `TfLiteAsyncKernel`."]
    pub fn TfLiteAsyncKernelCreate(kernel_data: *mut ::core::ffi::c_void)
        -> *mut TfLiteAsyncKernel;
}
extern "C" {
    #[doc = " Retrieves the kernel data for identifying the async kernel itself."]
    pub fn TfLiteAsyncKernelGetKernelData(
        async_kernel: *const TfLiteAsyncKernel,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Sets the callback for registering a piece of platform-specific hardware\n buffer object.\n `kernel_data` will be the same value supplied by `TfLiteAsyncKernelCreate`.\n\n `register_buffer`:\n Registers the buffer to `handle`.\n `buffer` and `attrs` lifespan is not guaranteed after the function call\n returns.\n kernels should save the stored attributes instead of caching the\n attribute map object itself.\n `io_type` specifies whether this buffer is used as an input buffer\n or an output buffer.\n `attrs` describes the attributes of the buffer object. It's guaranteed to be\n of kTfLiteBufferAttrMap type and not null. The application must provide\n `kTfLiteBufferAttrKeyResourceTypeName` attribute. When additional attributes\n (e.g. padding, size) are provided, the backend is responsible for validating\n those attributes to be compatible.\n Once its registered, TfLite runtime will assign and populate `handle` as\n the buffer handle.\n The backend will not own the actual buffer object, but the\n backend can choose to increase the ref count if underlying implementation\n supports that."]
    pub fn TfLiteAsyncKernelSetRegisterBuffer(
        async_kernel: *mut TfLiteAsyncKernel,
        register_buffer: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                io_type: TfLiteIoType,
                buffer: *const TfLiteBackendBuffer,
                attrs: *const TfLiteAttributeMap,
                handle: TfLiteBufferHandle,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for registering a buffer slice from previously registered\n hardware buffer object.\n\n `register_buffer_slice`:\n  Registers a buffer slice from a previously registered buffer object.\n `buffer_pool` is the handle of the buffer pool previously registered.\n `attrs` contains the information of the buffer slice.\n Once its registered, TfLite runtime will assign and populate `handle` as\n the buffer handle.\n NOTE: The backend is responsible to validate the slicing is \"valid\":\n * The slicing is not nested from another slice. (i.e. the `buffer_pool` is\n   a handle returned by `RegisterBuffer`.)\n * The attributes of the slice (e.g. size, offset) is of valid values\n   from the buffer pool."]
    pub fn TfLiteAsyncKernelSetRegisterBufferSlice(
        async_kernel: *mut TfLiteAsyncKernel,
        register_buffer_slice: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                buffer_pool: TfLiteBufferHandle,
                attrs: *const TfLiteAttributeMap,
                handle: TfLiteBufferHandle,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for unregistering a buffer handle.\n\n `unregister_buffer`:\n Unregisters a buffer or a buffer slice.\n `handle` is a buffer handle previously assigned via register_* calls.\n If the `handle` is not recognized, returns error.\n NOTE: Unregistering the buffer does not mean deallocating the buffer object.\n But the backend need to reduce the ref-count if ref counting is performed\n during buffer registration calls."]
    pub fn TfLiteAsyncKernelSetUnregisterBuffer(
        async_kernel: *mut TfLiteAsyncKernel,
        unregister_buffer: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                handle: TfLiteBufferHandle,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend reporting supported hardware buffer object\n type names."]
    pub fn TfLiteAsyncKernelSetSupportedBufferTypes(
        async_kernel: *mut TfLiteAsyncKernel,
        supported_buffer_types: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *const TfLiteAsyncKernel,
                io_type: TfLiteIoType,
                types: *mut *const *const ::core::ffi::c_char,
                n_types: *mut usize,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend reporting supported synchronization object\n type names."]
    pub fn TfLiteAsyncKernelSetSupportedSynchronizations(
        async_kernel: *mut TfLiteAsyncKernel,
        supported_synchronizations: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *const TfLiteAsyncKernel,
                io_type: TfLiteIoType,
                types: *mut *const *const ::core::ffi::c_char,
                n_types: *mut usize,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to reconcile execution environment\n attributes (e.g. buffer / synchronization object properties).\n\n `reconcile_restrictions`:\n Reconciles buffer or sync attributes for tensor at `tensor_index`.\n Fills `merged` with reconciled attributes.\n If `conflict` is provided, conflicting attributes should be provided there.\n If the type of the `user_provided_attributes` is not recognizable, returns\n error.\n If any of the attribute in the `user_provided_attributes` is not\n recognizable skip this attribute.\n Returns true if the attribute map type is recognizable and there's no\n conflicting attribute."]
    pub fn TfLiteAsyncKernelSetReconcileRestrictions(
        async_kernel: *mut TfLiteAsyncKernel,
        reconcile_restrictions: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *const TfLiteAsyncKernel,
                context: *const TfLiteOpaqueContext,
                node: *const TfLiteOpaqueNode,
                tensor_index: ::core::ffi::c_int,
                user_provided_attributes: *const TfLiteAttributeMap,
                merged: *mut TfLiteAttributeMap,
                conflict: *mut TfLiteAttributeMap,
            ) -> bool,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to set buffer / synchronization\n attributes.\n\n `set_attributes`:\n Sets the input / output buffer / synchronization object attributes.\n Backend kernel will check the attributes covers all the requirements.\n A typical workflow is for callers call Reconcile*Restrictions method\n above to have a merged attribute list, check all restrictions are met\n and set input / output attribute here.\n Returns kTfLiteOk if provided `attrs` covers all requirements."]
    pub fn TfLiteAsyncKernelSetSetAttributes(
        async_kernel: *mut TfLiteAsyncKernel,
        set_attributes: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
                tensor_index: ::core::ffi::c_int,
                attrs: *const TfLiteAttributeMap,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to set buffer attributes.\n\n `set_buffer_attributes`:\n Sets the attributes of the buffers.\n Backend kernel will check if the provided buffer has been registered, and\n update the map in the backend, so that the callers can retrieve specific\n buffer's attributes. `attrs` should be initialized\n before calling this function and could be constructed by calling\n TfLiteAttributeMapCreate(). The attributes will be sent to backend kernels\n and stored in the map with the buffer. `buffer` and `attrs` should not be\n nullptr. The buffer needs to be registered before calling this\n function. Returns kTfLiteOk if the buffer has been registered and\n callers can successfully set the attributes for a buffer."]
    pub fn TfLiteAsyncKernelSetSetBufferAttributes(
        async_kernel: *mut TfLiteAsyncKernel,
        set_buffer_attributes: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                buffer: *const TfLiteBackendBuffer,
                attrs: *const TfLiteAttributeMap,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to get buffer attributes.\n\n `get_buffer_attributes`:\n Gets the attributes of the buffers.\n Backend kernel will check if the provided buffer has been registered, and\n get the corresponding attributes from the map. `attrs` should be initialized\n before calling this function and could be constructed by calling\n TfLiteAttributeMapCreate(). `attrs` will be used to store the attributes\n obtained from the backend kernel. If `attrs` is a non-empty map, it will be\n overwritten by the attributes of the buffer. `buffer` and `attrs` should not\n be nullptr. The buffer needs to be registered before calling this function.\n Returns kTfLiteOk if the buffer has been registered and callers can\n successfully get the attributes for a buffer."]
    pub fn TfLiteAsyncKernelSetGetBufferAttributes(
        async_kernel: *mut TfLiteAsyncKernel,
        get_buffer_attributes: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                buffer: *const TfLiteBackendBuffer,
                attrs: *mut TfLiteAttributeMap,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback to prepare the kernels using the information from\n `set_attributes` calls."]
    pub fn TfLiteAsyncKernelSetPrepare(
        async_kernel: *mut TfLiteAsyncKernel,
        prepare: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to schedule an execution.\n\n `eval`:\n Schedules an execution with the information provided in task.\n The application is responsible for filling out buffer and sync mappings\n to tensors.\n Backend will set the sync ptr for related tensors if requested.\n i.e. SetOutputAttributes has sync implementation requested, and\n the TfLiteSynchronization is not null for the tensor in `task`.\n\n TfLite runtime guarantees that the task is in ready state (i.e. no\n un-ended execution for this task).\n\n Input synchronizations:\n If the synchronization of a input tensor is `kTfLiteSyncTypeNoSyncObj`\n type or it's nullptr, it means the data is ready during Eval call.\n If not, data will be available when the synchronization signals and the\n backend is responsible for closing the underlying synchronization.\n The backend is responsible for dedupping the input sync.\n\n Output synchronizations:\n If the synchronization type is `kTfLiteSyncTypeNoSyncObj` or is nullptr,\n the backend does not need to provide synchronization objects to the user.\n Otherwise, the backend need to provide the sync according to the sync type\n provided. The underlying sync object will be closed by the app (or\n downstream components).\n If there are multiple non-nullptr kTfLiteSynchronization provided for\n different output tensors, the backend is responsible for duplicating the\n synchronization."]
    pub fn TfLiteAsyncKernelSetEval(
        async_kernel: *mut TfLiteAsyncKernel,
        eval: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
                task: *mut TfLiteExecutionTask,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to wait for a specific execution.\n\n `wait`:\n Waits on the execution scheduled using the task to finish.\n TfLite runtime guarantees that the task has an un-ended execution.\n Callers should be able to call `Wait` on the same task from multiple\n threads, and those calls should return the same status (i.e. if the backend\n failed to successfully wait on the task, all `Wait` to the task should\n return the same error before a new invocation is scheduled). Returns\n kTfLiteOk if the task is finished (w/ or w/o blocking)."]
    pub fn TfLiteAsyncKernelSetWait(
        async_kernel: *mut TfLiteAsyncKernel,
        wait: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                task: *mut TfLiteExecutionTask,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Sets the callback for the backend to finish an execution and release all\n intermediate resources.\n\n `finish`:\n Finishes the task and clean up allocated resources for the task.\n May block if there's pending executions.\n This function will be called once and only once for individual task.\n Returns kTfLiteOk if there's no error. The backend is responsible to\n clean up task resources regardless there's error or not."]
    pub fn TfLiteAsyncKernelSetFinish(
        async_kernel: *mut TfLiteAsyncKernel,
        finish: ::core::option::Option<
            unsafe extern "C" fn(
                async_kernel: *mut TfLiteAsyncKernel,
                context: *mut TfLiteOpaqueContext,
                task: *mut TfLiteExecutionTask,
            ) -> TfLiteStatus,
        >,
    );
}
extern "C" {
    #[doc = " Releases `kernel`.\n Does not release `kernel_data`."]
    pub fn TfLiteAsyncKernelDelete(kernel: *mut TfLiteAsyncKernel);
}
extern "C" {
    #[doc = " Sets the buffer handle to the input / output tensor associated with\n `tensor_signature_name`.\n `task` and `tensor_signature_name` must not be nullptr.\n Returns kTfLiteError if the tensor is not found or nullptr args."]
    pub fn TfLiteExecutionTaskSetBuffer(
        task: *mut TfLiteExecutionTask,
        io_type: TfLiteIoType,
        tensor_signature_name: *const ::core::ffi::c_char,
        handle: TfLiteBufferHandle,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Sets the buffer handle to the input / output tensor associated with the\n tensor index.\n NOTE: This method does not check tensor index is pointing to a valid tensor.\n Caller need to make sure the tensor_index points to a valid tensor by\n using the element from AsyncSignatureRunner inputs / outputs array."]
    pub fn TfLiteExecutionTaskSetBufferByIndex(
        task: *mut TfLiteExecutionTask,
        tensor_index: ::core::ffi::c_int,
        handle: TfLiteBufferHandle,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the buffer handle of the input / output tensor associated with\n `tensor_signature_name`.\n `task` and `tensor_signature_name` must not be nullptr.\n Returns kTfLiteNullBufferHandle if the tensor is not found or null input."]
    pub fn TfLiteExecutionTaskGetBufferByName(
        task: *const TfLiteExecutionTask,
        io_type: TfLiteIoType,
        tensor_signature_name: *const ::core::ffi::c_char,
    ) -> TfLiteBufferHandle;
}
extern "C" {
    #[doc = " The same as `TfLiteExecutionTaskGetBufferByName` but takes tensor index\n instead of the name from signature."]
    pub fn TfLiteExecutionTaskGetBufferByIndex(
        task: *const TfLiteExecutionTask,
        tensor_index: ::core::ffi::c_int,
    ) -> TfLiteBufferHandle;
}
extern "C" {
    #[doc = " Sets the opaque sync object to the input / output tensor associated with\n `tensor_signature_name`.\n `task` and `tensor_signature_name` must not be nullptr.\n A nullptr `sync` esentially means the tensor data does not need\n synchronization.\n `task` does not take the ownership of `sync`, so caller needs to release\n `sync` when destroying the `task` with AsyncSignatureRunner::Finish.\n Returns kTfLiteError if the tensor is not found."]
    pub fn TfLiteExecutionTaskSetSync(
        task: *mut TfLiteExecutionTask,
        io_type: TfLiteIoType,
        tensor_signature_name: *const ::core::ffi::c_char,
        sync: *mut TfLiteSynchronization,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Sets the opaque sync object to the input / output tensor associated with the\n tensor index.\n NOTE: This method does not check tensor index is pointing to a\n valid tensor. Caller need to make sure the tensor_index points to a valid\n tensor by using the element from AsyncSignatureRunner inputs / outputs\n array."]
    pub fn TfLiteExecutionTaskSetSyncByIndex(
        task: *mut TfLiteExecutionTask,
        tensor_index: ::core::ffi::c_int,
        sync: *mut TfLiteSynchronization,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the sync object of the input / output tensor associated with\n `tensor_signature_name`.\n `task` and `tensor_signature_name` must not be nullptr.\n Returns nullptr if the tensor is not found or null input."]
    pub fn TfLiteExecutionTaskGetSyncByName(
        task: *const TfLiteExecutionTask,
        io_type: TfLiteIoType,
        tensor_signature_name: *const ::core::ffi::c_char,
    ) -> *mut TfLiteSynchronization;
}
extern "C" {
    #[doc = " The same as `TfLiteExecutionTaskGetSyncByName` but takes tensor index\n instead of the name from signature."]
    pub fn TfLiteExecutionTaskGetSyncByIndex(
        task: *const TfLiteExecutionTask,
        tensor_index: ::core::ffi::c_int,
    ) -> *mut TfLiteSynchronization;
}
extern "C" {
    #[doc = " Task execution data\n Backends may store task specific data for executions. This ease the burden\n for backends to maintain the mapping across different tasks."]
    pub fn TfLiteExecutionTaskGetDelegateExecutionData(
        task: *const TfLiteExecutionTask,
        kernel: *mut TfLiteAsyncKernel,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn TfLiteExecutionTaskSetDelegateExecutionData(
        task: *mut TfLiteExecutionTask,
        kernel: *mut TfLiteAsyncKernel,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Task status\n Thread safe accessors for the latest status of the task."]
    pub fn TfLiteExecutionTaskGetStatus(task: *const TfLiteExecutionTask) -> TfLiteStatus;
}
extern "C" {
    pub fn TfLiteExecutionTaskSetStatus(task: *mut TfLiteExecutionTask, status: TfLiteStatus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAsyncSignatureRunner {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns a new async signature runner using the provided interpreter and\n signature key, or nullptr on failure.\n\n NOTE: `signature_key` is a null-terminated C string that must match the\n key of a signature in the interpreter's model.\n\n NOTE: The returned signature runner should be destroyed, by calling\n TfLiteAsyncSignatureRunnerDelete(), before the interpreter is destroyed.\n\n WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterGetAsyncSignatureRunner(
        interpreter: *const TfLiteInterpreter,
        signature_key: *const ::core::ffi::c_char,
    ) -> *mut TfLiteAsyncSignatureRunner;
}
extern "C" {
    #[doc = " Registers a TfLiteBackendBuffer to the backend.\n `async_signature_runner`, `buffer`, `attrs` and `handle` should be non-null.\n If the hardware buffer wrapped in `buffer` is successfully registered,\n `handle` will be filled with a new buffer handle. Caller can use the buffer\n handle as input / output buffer in `TfLiteExecutionTask`.\n Returns kTfLiteError if the registration failed."]
    pub fn TfLiteAsyncSignatureRunnerRegisterBuffer(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        io_type: TfLiteIoType,
        buffer: *const TfLiteBackendBuffer,
        attrs: *const TfLiteAttributeMap,
        handle: *mut TfLiteBufferHandle,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Registers a buffer slice from a previously registered handle `buffer_pool`.\n `async_signature_runner`, `attrs` and `handle` should be non-null.\n If the buffer slice described by `attrs` is successfully registered,\n output `handle` will be filled with a new buffer handle value.\n NOTE: `attrs` should contain the information about the buffer slice,\n e.g. offset and size of the size (if applicable).\n Returns kTfLiteError if the registration failed."]
    pub fn TfLiteAsyncSignatureRunnerRegisterBufferSlice(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        buffer_pool: TfLiteBufferHandle,
        attrs: *const TfLiteAttributeMap,
        handle: *mut TfLiteBufferHandle,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Unregisters a hardware buffer object (or buffer slice) with `handle`.\n Buffer slices should be unregistered before unregistering the buffer pool\n it belongs to.\n Returns kTfLiteError if `handle` is not recognized."]
    pub fn TfLiteAsyncSignatureRunnerUnregisterBuffer(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        handle: TfLiteBufferHandle,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns supported platform-specific hardware buffer types.\n\n Output `types` will be a array of C strings that can be used as the\n value of `kTfLiteBufferAttrKeyResourceTypeName`.\n Output `num_types` is the size of the `types` array, and can be used to\n access elements in `types`.\n\n NOTE: The lifetime of the returned array is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetSupportedBufferTypes(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        io_type: TfLiteIoType,
        types: *mut *const *const ::core::ffi::c_char,
        num_types: *mut usize,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns supported platform-specific synchronization object types.\n\n Output `types` will be a array of C strings that can be used as the\n value of `kTfLiteSynchronizationAttrKeyObjectTypeName`.\n Output `num_types` is the size of the `types` array, and can be used to\n access elements in `types`.\n\n NOTE: The lifetime of the returned array is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetSupportedSynchronizationTypes(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        io_type: TfLiteIoType,
        types: *mut *const *const ::core::ffi::c_char,
        num_types: *mut usize,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Reconciles restrictions with the backend for I/O tensor called `name`.\n The backend will read `user_provided_attributes` and tries to reconcile\n those attributes. The backend will also populate its own restrictions\n back to the caller.\n The merged attributes will be populated to `merged`. For attributes that\n the backend does not know or not care about, those will also be copied to\n `merged` attributes.\n If there's a conflicting attribute, it will be populated to `conflict` if\n it's provided.\n `user_provided_attributes` and `merged` should not be nullptr.\n Returns true if the reconcilation succeeded and there's no\n conflicting attributes."]
    pub fn TfLiteAsyncSignatureRunnerReconcileRestrictions(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        io_type: TfLiteIoType,
        name: *const ::core::ffi::c_char,
        user_provided_attributes: *const TfLiteAttributeMap,
        merged: *mut TfLiteAttributeMap,
        conflict: *mut TfLiteAttributeMap,
    ) -> bool;
}
extern "C" {
    #[doc = " Reconciles restrictions with the backend for I/O tensor at `tensor_index`.\n The backend will read `user_provided_attributes` and tries to reconcile\n those attributes. The backend will also populate its own restrictions\n back to the caller.\n The merged attributes will be populated to `merged`. For attributes that\n the backend does not know or not care about, those will also be copied to\n `merged` attributes.\n If there's a conflicting attribute, it will be populated to `conflict` if\n it's provided.\n `user_provided_attributes` and `merged` should not be nullptr.\n Returns true if the reconcilation succeeded and there's no\n conflicting attributes."]
    pub fn TfLiteAsyncSignatureRunnerReconcileRestrictionsByIndex(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        tensor_index: ::core::ffi::c_int,
        user_provided_attributes: *const TfLiteAttributeMap,
        merged: *mut TfLiteAttributeMap,
        conflict: *mut TfLiteAttributeMap,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalizes I/O tensor `name`'s attributes with `attrs`.\n The attributes will be forwarded to all backend kernels that depends on\n tensor. Must call `TfLiteAsyncSignatureRunnerPrepareBackends` after setting\n new attributes.\n Callers needs to ensure the lifetime of `name` and `attrs` before this\n function returns, and those may be deallocated afterwards.\n Returns true if all backends accept the `attrs`."]
    pub fn TfLiteAsyncSignatureRunnerSetAttributes(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        io_type: TfLiteIoType,
        name: *const ::core::ffi::c_char,
        attrs: *const TfLiteAttributeMap,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Finalizes I/O tensor at `tensor_index`'s attributes with `attrs`.\n The attributes will be forwarded to all backend kernels that depends on\n tensor. Must call `TfLiteAsyncSignatureRunnerPrepareBackends` after setting\n new attributes.\n Callers needs to ensure the lifetime of `name` and `attrs` before this\n function returns, and those may be deallocated afterwards.\n Returns true if all backends accept the `attrs`."]
    pub fn TfLiteAsyncSignatureRunnerSetAttributesByIndex(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        tensor_index: ::core::ffi::c_int,
        attrs: *const TfLiteAttributeMap,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Prepares delegate backends for execution.\n Must be called after `TfLiteAsyncSignatureRunnerSetAttributes` and before\n `TfLiteAsyncSignatureRunnerCreateTask`."]
    pub fn TfLiteAsyncSignatureRunnerPrepareBackends(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Creates an execution task for this signature.\n Must be called after `TfLiteAsyncSignatureRunnerPrepareBackends` otherwise\n returns nullptr.\n When creating a task, all intermediate resources will be allocated\n for this task.\n Caller owns the returned task and must release it by calling\n `TfLiteAsyncSignatureRunnerFinish`.\n Returns nullptr if the task allocation failed."]
    pub fn TfLiteAsyncSignatureRunnerCreateTask(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
    ) -> *mut TfLiteExecutionTask;
}
extern "C" {
    #[doc = " Schedules an asynchronous execution with I/O information\n provided in `task`.\n `task` should not be nullptr.\n\n NOTE: For the same `task`,\n `Wait` and `InvokeAsync` should be called in pairs, unless `Finish(task)` is\n called and `task` is freed. The application is responsible\n to call `Wait` after `InvokeAsync` even if all output tensors are associated\n with synchronizations.\n\n Returns kTfLiteError if any backend kernels failed to schedule\n the execution."]
    pub fn TfLiteAsyncSignatureRunnerInvokeAsync(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        task: *mut TfLiteExecutionTask,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Blocks and wait for execution tied to `task` to finish.\n `task` should not be nullptr.\n Can be called from multiple threads. All calls will block until the\n task finishes execution.\n\n NOTE: For the same `task`,\n `Wait` and `InvokeAsync` should be called in pairs, unless `Finish(task)` is\n called and `task` is freed. The application is responsible\n to call `Wait` after `InvokeAsync` even if all output tensors are associated\n with synchronizations.\n If `TfLiteAsyncSignatureRunnerWait` is called without a matching call to\n `TfLiteAsyncSignatureRunnerInvokeAsync`, returns the latest status code (by\n default `kTfLiteOk`).\n\n Returns kTfLiteError if any backends failed to finish the execution.\n If the task is currently idle, it will return its latest status code."]
    pub fn TfLiteAsyncSignatureRunnerWait(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        task: *mut TfLiteExecutionTask,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Finishes the task and release all intermediate resources tied to\n this task. Must be called exactly once for each `task` object.\n If there's ongoing execution, this will block wait for the execution\n to finish.\n `task` should not be nullptr and will be deleted.\n NOTE: Caller needs to ensure `Finish` is not called concurrently with\n `InvokeAsync` or `Wait`.\n Returns kTfLiteError if fails to release the task. The task will be\n destroyed regardless of error or not."]
    pub fn TfLiteAsyncSignatureRunnerFinish(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        task: *mut TfLiteExecutionTask,
    ) -> TfLiteStatus;
}
extern "C" {
    #[doc = " Returns the number of input tensors associated with the signature."]
    pub fn TfLiteAsyncSignatureRunnerGetInputCount(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the (null-terminated) name of the Nth input in a signature, where N\n is specified as `input_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetInputName(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        input_index: i32,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the number of output tensors associated with the signature."]
    pub fn TfLiteAsyncSignatureRunnerGetOutputCount(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the (null-terminated) name of the Nth output in a signature, where\n N is specified as `output_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetOutputName(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        output_index: i32,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the input tensor metadata identified by `input_name` in the given\n signature.\n Returns nullptr if the given name is not valid.\n\n NOTE: For AsyncSignatureRunner, tensor data are not stored within\n `TfLiteOpaqueTensors` but in platform-specific hardware buffer objects.\n This method is only used for accessing the metadata like shape and data type\n of the input tensors.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetInputTensor(
        async_signature_runner: *mut TfLiteAsyncSignatureRunner,
        input_name: *const ::core::ffi::c_char,
    ) -> *const TfLiteOpaqueTensor;
}
extern "C" {
    #[doc = " Returns the output tensor metadata identified by `output_name` in the given\n signature.\n Returns nullptr if the given name is not valid.\n\n Note: For AsyncSignatureRunner, tensor data are not stored within\n `TfLiteOpaqueTensors` but in platform-specific hardware buffer objects.\n This method is only used for accessing the metadata like shape and data type\n of the output tensors.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetOutputTensor(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        output_name: *const ::core::ffi::c_char,
    ) -> *const TfLiteOpaqueTensor;
}
extern "C" {
    #[doc = " Destroys the async signature runner."]
    pub fn TfLiteAsyncSignatureRunnerDelete(signature_runner: *mut TfLiteAsyncSignatureRunner);
}
extern "C" {
    #[doc = " Returns a pointer to an array of input tensor indices.  The length of the\n array can be obtained via a call to\n `TfLiteAsyncSignatureRunnerGetInputCount`.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerInputTensorIndices(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
    ) -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns a pointer to an array of output tensor indices.  The length of the\n array can be obtained via a call to\n `TfLiteAsyncSignatureRunnerGetOutputCount`.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerOutputTensorIndices(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
    ) -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the tensor metadata identified by `index` in the given\n signature.\n Returns nullptr if the given index is not valid or out of bound.\n\n NOTE: For AsyncSignatureRunner, tensor data are not stored within\n `TfLiteOpaqueTensors` but in platform-specific hardware buffer objects.\n This method is only used for accessing the metadata like shape and data type\n of the input tensors.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `async_signature_runner`."]
    pub fn TfLiteAsyncSignatureRunnerGetTensor(
        async_signature_runner: *const TfLiteAsyncSignatureRunner,
        index: ::core::ffi::c_int,
    ) -> *const TfLiteOpaqueTensor;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::core::ffi::c_uint,
    pub __wchb: [::core::ffi::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::core::ffi::c_int,
    pub _IO_read_ptr: *mut ::core::ffi::c_char,
    pub _IO_read_end: *mut ::core::ffi::c_char,
    pub _IO_read_base: *mut ::core::ffi::c_char,
    pub _IO_write_base: *mut ::core::ffi::c_char,
    pub _IO_write_ptr: *mut ::core::ffi::c_char,
    pub _IO_write_end: *mut ::core::ffi::c_char,
    pub _IO_buf_base: *mut ::core::ffi::c_char,
    pub _IO_buf_end: *mut ::core::ffi::c_char,
    pub _IO_save_base: *mut ::core::ffi::c_char,
    pub _IO_backup_base: *mut ::core::ffi::c_char,
    pub _IO_save_end: *mut ::core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::core::ffi::c_int,
    pub _flags2: ::core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::core::ffi::c_ushort,
    pub _vtable_offset: ::core::ffi::c_schar,
    pub _shortbuf: [::core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::core::ffi::c_int,
    pub _unused2: [::core::ffi::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::core::ffi::c_char,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::core::ffi::c_int,
        __old: *const ::core::ffi::c_char,
        __newfd: ::core::ffi::c_int,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::core::ffi::c_char,
        __pfx: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::core::ffi::c_int, __modes: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::core::ffi::c_void,
        __len: usize,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::core::ffi::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::core::ffi::c_char,
        __modes: ::core::ffi::c_int,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(__w: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __s: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::core::ffi::c_long,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[doc = " Retrieves asynchronous kernel.\n\n If the `async_kernel` field is nullptr, it means the operation described\n by this TfLiteRegistration object does not support asynchronous execution.\n Otherwise, the function that the field points to should only be called for\n delegate kernel nodes, i.e. `node` should be a delegate kernel node\n created by applying a delegate. If the function returns nullptr, that\n means that the underlying delegate does not support asynchronous execution\n for this `node`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAsyncKernel {
    pub _address: u8,
}
